import { getChangeDetectionHandler } from './utils';
import { Subject, } from 'rxjs';
import { distinctUntilChanged, map, switchAll, tap } from 'rxjs/operators';
import { toObservableValue } from './projections';
export function setUpWork(cfg) {
    var render = getChangeDetectionHandler(cfg.ngZone, cfg.cdRef);
    return function () { return render(cfg.context); };
}
/**
 * class CdAware
 *
 * @description
 * This abstract class holds all the shared logic for the push pipe and the let directive
 * responsible for change detection
 * If you extend this class you need to implement how the update of the rendered value happens.
 * Also custom behaviour is something you need to implement in the extending class
 */
export function createCdAware(cfg) {
    var observablesSubject = new Subject();
    // We have to defer the setup of observables$ until subscription as getConfigurableBehaviour is defined in the
    // extending class. So getConfigurableBehaviour is not available in the abstract layer
    var observables$ = observablesSubject.pipe(
    // Ignore potential observables of the same instances
    distinctUntilChanged(), 
    // Try to convert it to values, throw if not possible
    map(toObservableValue), tap(function (v) {
        cfg.resetContextObserver.next(v);
        cfg.work();
    }), map(function (value$) {
        return value$.pipe(distinctUntilChanged(), tap(cfg.updateViewContextObserver));
    }), 
    // e.g. coalescing
    cfg.configurableBehaviour, 
    // Unsubscribe from previous observables
    // Then flatten the latest internal observables into the output
    // @NOTICE applied behaviour (on the values, not the observable) will fire here
    switchAll(), tap(function () { return cfg.work(); }));
    return {
        next: function (value) {
            observablesSubject.next(value);
        },
        subscribe: function () {
            return observables$.subscribe();
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2QtYXdhcmUuYWJzdHJhY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2NvbXBvbmVudC9zcmMvY29yZS9jZC1hd2FyZS5hYnN0cmFjdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDcEQsT0FBTyxFQUlMLE9BQU8sR0FHUixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQWdCbEQsTUFBTSxVQUFVLFNBQVMsQ0FBQyxHQUFlO0lBQ3ZDLElBQU0sTUFBTSxHQUE4Qix5QkFBeUIsQ0FDakUsR0FBRyxDQUFDLE1BQU0sRUFDVixHQUFHLENBQUMsS0FBSyxDQUNWLENBQUM7SUFDRixPQUFPLGNBQU0sT0FBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFuQixDQUFtQixDQUFDO0FBQ25DLENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUksR0FPaEM7SUFDQyxJQUFNLGtCQUFrQixHQUFHLElBQUksT0FBTyxFQUVuQyxDQUFDO0lBQ0osOEdBQThHO0lBQzlHLHNGQUFzRjtJQUN0RixJQUFNLFlBQVksR0FFZCxrQkFBa0IsQ0FBQyxJQUFJO0lBQ3pCLHFEQUFxRDtJQUNyRCxvQkFBb0IsRUFBRTtJQUN0QixxREFBcUQ7SUFDckQsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEVBQ3RCLEdBQUcsQ0FBQyxVQUFDLENBQU07UUFDVCxHQUFHLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNiLENBQUMsQ0FBQyxFQUNGLEdBQUcsQ0FBQyxVQUFBLE1BQU07UUFDUixPQUFBLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFBdkUsQ0FBdUUsQ0FDeEU7SUFDRCxrQkFBa0I7SUFDbEIsR0FBRyxDQUFDLHFCQUFxQjtJQUN6Qix3Q0FBd0M7SUFDeEMsK0RBQStEO0lBQy9ELCtFQUErRTtJQUMvRSxTQUFTLEVBQUUsRUFDWCxHQUFHLENBQUMsY0FBTSxPQUFBLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBVixDQUFVLENBQUMsQ0FDdEIsQ0FBQztJQUVGLE9BQU87UUFDTCxJQUFJLEVBQUosVUFBSyxLQUFVO1lBQ2Isa0JBQWtCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pDLENBQUM7UUFDRCxTQUFTLEVBQVQ7WUFDRSxPQUFPLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNsQyxDQUFDO0tBQytCLENBQUM7QUFDckMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGdldENoYW5nZURldGVjdGlvbkhhbmRsZXIgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIE5leHRPYnNlcnZlcixcbiAgT2JzZXJ2YWJsZSxcbiAgUGFydGlhbE9ic2VydmVyLFxuICBTdWJqZWN0LFxuICBTdWJzY3JpYmFibGUsXG4gIFN1YnNjcmlwdGlvbixcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCBzd2l0Y2hBbGwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IHRvT2JzZXJ2YWJsZVZhbHVlIH0gZnJvbSAnLi9wcm9qZWN0aW9ucyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29hbGVzY2luZ0NvbmZpZyB7XG4gIG9wdGltaXplZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDZEF3YXJlPFU+IGV4dGVuZHMgU3Vic2NyaWJhYmxlPFU+IHtcbiAgbmV4dDogKHZhbHVlOiBPYnNlcnZhYmxlPFU+IHwgUHJvbWlzZTxVPiB8IG51bGwgfCB1bmRlZmluZWQpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya0NvbmZpZyB7XG4gIGNvbnRleHQ6IGFueTtcbiAgbmdab25lOiBOZ1pvbmU7XG4gIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFVwV29yayhjZmc6IFdvcmtDb25maWcpOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgcmVuZGVyOiAoY29tcG9uZW50PzogYW55KSA9PiB2b2lkID0gZ2V0Q2hhbmdlRGV0ZWN0aW9uSGFuZGxlcihcbiAgICBjZmcubmdab25lLFxuICAgIGNmZy5jZFJlZlxuICApO1xuICByZXR1cm4gKCkgPT4gcmVuZGVyKGNmZy5jb250ZXh0KTtcbn1cblxuLyoqXG4gKiBjbGFzcyBDZEF3YXJlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGFic3RyYWN0IGNsYXNzIGhvbGRzIGFsbCB0aGUgc2hhcmVkIGxvZ2ljIGZvciB0aGUgcHVzaCBwaXBlIGFuZCB0aGUgbGV0IGRpcmVjdGl2ZVxuICogcmVzcG9uc2libGUgZm9yIGNoYW5nZSBkZXRlY3Rpb25cbiAqIElmIHlvdSBleHRlbmQgdGhpcyBjbGFzcyB5b3UgbmVlZCB0byBpbXBsZW1lbnQgaG93IHRoZSB1cGRhdGUgb2YgdGhlIHJlbmRlcmVkIHZhbHVlIGhhcHBlbnMuXG4gKiBBbHNvIGN1c3RvbSBiZWhhdmlvdXIgaXMgc29tZXRoaW5nIHlvdSBuZWVkIHRvIGltcGxlbWVudCBpbiB0aGUgZXh0ZW5kaW5nIGNsYXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDZEF3YXJlPFU+KGNmZzoge1xuICB3b3JrOiAoKSA9PiB2b2lkO1xuICByZXNldENvbnRleHRPYnNlcnZlcjogTmV4dE9ic2VydmVyPHVua25vd24+O1xuICBjb25maWd1cmFibGVCZWhhdmlvdXI6IChcbiAgICBvOiBPYnNlcnZhYmxlPE9ic2VydmFibGU8VSB8IG51bGwgfCB1bmRlZmluZWQ+PlxuICApID0+IE9ic2VydmFibGU8T2JzZXJ2YWJsZTxVIHwgbnVsbCB8IHVuZGVmaW5lZD4+O1xuICB1cGRhdGVWaWV3Q29udGV4dE9ic2VydmVyOiBQYXJ0aWFsT2JzZXJ2ZXI8VSB8IG51bGwgfCB1bmRlZmluZWQ+O1xufSk6IENkQXdhcmU8VSB8IHVuZGVmaW5lZCB8IG51bGw+IHtcbiAgY29uc3Qgb2JzZXJ2YWJsZXNTdWJqZWN0ID0gbmV3IFN1YmplY3Q8XG4gICAgT2JzZXJ2YWJsZTxVPiB8IFByb21pc2U8VT4gfCBudWxsIHwgdW5kZWZpbmVkXG4gID4oKTtcbiAgLy8gV2UgaGF2ZSB0byBkZWZlciB0aGUgc2V0dXAgb2Ygb2JzZXJ2YWJsZXMkIHVudGlsIHN1YnNjcmlwdGlvbiBhcyBnZXRDb25maWd1cmFibGVCZWhhdmlvdXIgaXMgZGVmaW5lZCBpbiB0aGVcbiAgLy8gZXh0ZW5kaW5nIGNsYXNzLiBTbyBnZXRDb25maWd1cmFibGVCZWhhdmlvdXIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYWJzdHJhY3QgbGF5ZXJcbiAgY29uc3Qgb2JzZXJ2YWJsZXMkOiBPYnNlcnZhYmxlPFxuICAgIFUgfCB1bmRlZmluZWQgfCBudWxsXG4gID4gPSBvYnNlcnZhYmxlc1N1YmplY3QucGlwZShcbiAgICAvLyBJZ25vcmUgcG90ZW50aWFsIG9ic2VydmFibGVzIG9mIHRoZSBzYW1lIGluc3RhbmNlc1xuICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgLy8gVHJ5IHRvIGNvbnZlcnQgaXQgdG8gdmFsdWVzLCB0aHJvdyBpZiBub3QgcG9zc2libGVcbiAgICBtYXAodG9PYnNlcnZhYmxlVmFsdWUpLFxuICAgIHRhcCgodjogYW55KSA9PiB7XG4gICAgICBjZmcucmVzZXRDb250ZXh0T2JzZXJ2ZXIubmV4dCh2KTtcbiAgICAgIGNmZy53b3JrKCk7XG4gICAgfSksXG4gICAgbWFwKHZhbHVlJCA9PlxuICAgICAgdmFsdWUkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgdGFwKGNmZy51cGRhdGVWaWV3Q29udGV4dE9ic2VydmVyKSlcbiAgICApLFxuICAgIC8vIGUuZy4gY29hbGVzY2luZ1xuICAgIGNmZy5jb25maWd1cmFibGVCZWhhdmlvdXIsXG4gICAgLy8gVW5zdWJzY3JpYmUgZnJvbSBwcmV2aW91cyBvYnNlcnZhYmxlc1xuICAgIC8vIFRoZW4gZmxhdHRlbiB0aGUgbGF0ZXN0IGludGVybmFsIG9ic2VydmFibGVzIGludG8gdGhlIG91dHB1dFxuICAgIC8vIEBOT1RJQ0UgYXBwbGllZCBiZWhhdmlvdXIgKG9uIHRoZSB2YWx1ZXMsIG5vdCB0aGUgb2JzZXJ2YWJsZSkgd2lsbCBmaXJlIGhlcmVcbiAgICBzd2l0Y2hBbGwoKSxcbiAgICB0YXAoKCkgPT4gY2ZnLndvcmsoKSlcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIG5leHQodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgb2JzZXJ2YWJsZXNTdWJqZWN0Lm5leHQodmFsdWUpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKCk6IFN1YnNjcmlwdGlvbiB7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZXMkLnN1YnNjcmliZSgpO1xuICAgIH0sXG4gIH0gYXMgQ2RBd2FyZTxVIHwgdW5kZWZpbmVkIHwgbnVsbD47XG59XG4iXX0=