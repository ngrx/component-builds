import { getChangeDetectionHandler } from './utils';
import { Subject, } from 'rxjs';
import { distinctUntilChanged, map, switchAll, tap } from 'rxjs/operators';
import { toObservableValue } from './projections';
export function setUpWork(cfg) {
    var render = getChangeDetectionHandler(cfg.ngZone, cfg.cdRef);
    return function () { return render(cfg.context); };
}
/**
 * class CdAware
 *
 * @description
 * This abstract class holds all the shared logic for the push pipe and the let directive
 * responsible for change detection
 * If you extend this class you need to implement how the update of the rendered value happens.
 * Also custom behaviour is something you need to implement in the extending class
 */
export function createCdAware(cfg) {
    var observablesSubject = new Subject();
    // We have to defer the setup of observables$ until subscription as getConfigurableBehaviour is defined in the
    // extending class. So getConfigurableBehaviour is not available in the abstract layer
    var observables$ = observablesSubject.pipe(
    // Ignore potential observables of the same instances
    distinctUntilChanged(), 
    // Try to convert it to values, throw if not possible
    map(function (v) { return toObservableValue(v); }), tap(function (v) {
        cfg.resetContextObserver.next(v);
        cfg.work();
    }), map(function (value$) {
        return value$.pipe(distinctUntilChanged(), tap(cfg.updateViewContextObserver));
    }), 
    // e.g. coalescing
    cfg.configurableBehaviour, 
    // Unsubscribe from previous observables
    // Then flatten the latest internal observables into the output
    // @NOTICE applied behaviour (on the values, not the observable) will fire here
    switchAll(), tap(function () { return cfg.work(); }));
    return {
        next: function (value) {
            observablesSubject.next(value);
        },
        subscribe: function () {
            return observables$.subscribe();
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2QtYXdhcmUuYWJzdHJhY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2NvbXBvbmVudC9zcmMvY29yZS9jZC1hd2FyZS5hYnN0cmFjdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDcEQsT0FBTyxFQUlMLE9BQU8sR0FHUixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQWdCbEQsTUFBTSxVQUFVLFNBQVMsQ0FBQyxHQUFlO0lBQ3ZDLElBQU0sTUFBTSxHQUE4Qix5QkFBeUIsQ0FDakUsR0FBRyxDQUFDLE1BQU0sRUFDVixHQUFHLENBQUMsS0FBSyxDQUNWLENBQUM7SUFDRixPQUFPLGNBQU0sT0FBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFuQixDQUFtQixDQUFDO0FBQ25DLENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUksR0FPaEM7SUFDQyxJQUFNLGtCQUFrQixHQUFHLElBQUksT0FBTyxFQUVuQyxDQUFDO0lBQ0osOEdBQThHO0lBQzlHLHNGQUFzRjtJQUN0RixJQUFNLFlBQVksR0FFZCxrQkFBa0IsQ0FBQyxJQUFJO0lBQ3pCLHFEQUFxRDtJQUNyRCxvQkFBb0IsRUFBRTtJQUN0QixxREFBcUQ7SUFDckQsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEVBQXBCLENBQW9CLENBQUMsRUFDOUIsR0FBRyxDQUFDLFVBQUMsQ0FBTTtRQUNULEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2IsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLFVBQUEsTUFBTTtRQUNSLE9BQUEsTUFBTSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUF2RSxDQUF1RSxDQUN4RTtJQUNELGtCQUFrQjtJQUNsQixHQUFHLENBQUMscUJBQXFCO0lBQ3pCLHdDQUF3QztJQUN4QywrREFBK0Q7SUFDL0QsK0VBQStFO0lBQy9FLFNBQVMsRUFBRSxFQUNYLEdBQUcsQ0FBQyxjQUFNLE9BQUEsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFWLENBQVUsQ0FBQyxDQUN0QixDQUFDO0lBRUYsT0FBTztRQUNMLElBQUksRUFBSixVQUFLLEtBQVU7WUFDYixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDakMsQ0FBQztRQUNELFNBQVMsRUFBVDtZQUNFLE9BQU8sWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2xDLENBQUM7S0FDK0IsQ0FBQztBQUNyQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZ2V0Q2hhbmdlRGV0ZWN0aW9uSGFuZGxlciB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgTmV4dE9ic2VydmVyLFxuICBPYnNlcnZhYmxlLFxuICBQYXJ0aWFsT2JzZXJ2ZXIsXG4gIFN1YmplY3QsXG4gIFN1YnNjcmliYWJsZSxcbiAgU3Vic2NyaXB0aW9uLFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIHN3aXRjaEFsbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgdG9PYnNlcnZhYmxlVmFsdWUgfSBmcm9tICcuL3Byb2plY3Rpb25zJztcblxuZXhwb3J0IGludGVyZmFjZSBDb2FsZXNjaW5nQ29uZmlnIHtcbiAgb3B0aW1pemVkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENkQXdhcmU8VT4gZXh0ZW5kcyBTdWJzY3JpYmFibGU8VT4ge1xuICBuZXh0OiAodmFsdWU6IE9ic2VydmFibGU8VT4gfCBQcm9taXNlPFU+IHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3JrQ29uZmlnIHtcbiAgY29udGV4dDogYW55O1xuICBuZ1pvbmU6IE5nWm9uZTtcbiAgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VXBXb3JrKGNmZzogV29ya0NvbmZpZyk6ICgpID0+IHZvaWQge1xuICBjb25zdCByZW5kZXI6IChjb21wb25lbnQ/OiBhbnkpID0+IHZvaWQgPSBnZXRDaGFuZ2VEZXRlY3Rpb25IYW5kbGVyKFxuICAgIGNmZy5uZ1pvbmUsXG4gICAgY2ZnLmNkUmVmXG4gICk7XG4gIHJldHVybiAoKSA9PiByZW5kZXIoY2ZnLmNvbnRleHQpO1xufVxuXG4vKipcbiAqIGNsYXNzIENkQXdhcmVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgYWJzdHJhY3QgY2xhc3MgaG9sZHMgYWxsIHRoZSBzaGFyZWQgbG9naWMgZm9yIHRoZSBwdXNoIHBpcGUgYW5kIHRoZSBsZXQgZGlyZWN0aXZlXG4gKiByZXNwb25zaWJsZSBmb3IgY2hhbmdlIGRldGVjdGlvblxuICogSWYgeW91IGV4dGVuZCB0aGlzIGNsYXNzIHlvdSBuZWVkIHRvIGltcGxlbWVudCBob3cgdGhlIHVwZGF0ZSBvZiB0aGUgcmVuZGVyZWQgdmFsdWUgaGFwcGVucy5cbiAqIEFsc28gY3VzdG9tIGJlaGF2aW91ciBpcyBzb21ldGhpbmcgeW91IG5lZWQgdG8gaW1wbGVtZW50IGluIHRoZSBleHRlbmRpbmcgY2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNkQXdhcmU8VT4oY2ZnOiB7XG4gIHdvcms6ICgpID0+IHZvaWQ7XG4gIHJlc2V0Q29udGV4dE9ic2VydmVyOiBOZXh0T2JzZXJ2ZXI8dW5rbm93bj47XG4gIGNvbmZpZ3VyYWJsZUJlaGF2aW91cjogKFxuICAgIG86IE9ic2VydmFibGU8T2JzZXJ2YWJsZTxVIHwgbnVsbCB8IHVuZGVmaW5lZD4+XG4gICkgPT4gT2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFUgfCBudWxsIHwgdW5kZWZpbmVkPj47XG4gIHVwZGF0ZVZpZXdDb250ZXh0T2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxVIHwgbnVsbCB8IHVuZGVmaW5lZD47XG59KTogQ2RBd2FyZTxVIHwgdW5kZWZpbmVkIHwgbnVsbD4ge1xuICBjb25zdCBvYnNlcnZhYmxlc1N1YmplY3QgPSBuZXcgU3ViamVjdDxcbiAgICBPYnNlcnZhYmxlPFU+IHwgUHJvbWlzZTxVPiB8IG51bGwgfCB1bmRlZmluZWRcbiAgPigpO1xuICAvLyBXZSBoYXZlIHRvIGRlZmVyIHRoZSBzZXR1cCBvZiBvYnNlcnZhYmxlcyQgdW50aWwgc3Vic2NyaXB0aW9uIGFzIGdldENvbmZpZ3VyYWJsZUJlaGF2aW91ciBpcyBkZWZpbmVkIGluIHRoZVxuICAvLyBleHRlbmRpbmcgY2xhc3MuIFNvIGdldENvbmZpZ3VyYWJsZUJlaGF2aW91ciBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBhYnN0cmFjdCBsYXllclxuICBjb25zdCBvYnNlcnZhYmxlcyQ6IE9ic2VydmFibGU8XG4gICAgVSB8IHVuZGVmaW5lZCB8IG51bGxcbiAgPiA9IG9ic2VydmFibGVzU3ViamVjdC5waXBlKFxuICAgIC8vIElnbm9yZSBwb3RlbnRpYWwgb2JzZXJ2YWJsZXMgb2YgdGhlIHNhbWUgaW5zdGFuY2VzXG4gICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAvLyBUcnkgdG8gY29udmVydCBpdCB0byB2YWx1ZXMsIHRocm93IGlmIG5vdCBwb3NzaWJsZVxuICAgIG1hcCh2ID0+IHRvT2JzZXJ2YWJsZVZhbHVlKHYpKSxcbiAgICB0YXAoKHY6IGFueSkgPT4ge1xuICAgICAgY2ZnLnJlc2V0Q29udGV4dE9ic2VydmVyLm5leHQodik7XG4gICAgICBjZmcud29yaygpO1xuICAgIH0pLFxuICAgIG1hcCh2YWx1ZSQgPT5cbiAgICAgIHZhbHVlJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHRhcChjZmcudXBkYXRlVmlld0NvbnRleHRPYnNlcnZlcikpXG4gICAgKSxcbiAgICAvLyBlLmcuIGNvYWxlc2NpbmdcbiAgICBjZmcuY29uZmlndXJhYmxlQmVoYXZpb3VyLFxuICAgIC8vIFVuc3Vic2NyaWJlIGZyb20gcHJldmlvdXMgb2JzZXJ2YWJsZXNcbiAgICAvLyBUaGVuIGZsYXR0ZW4gdGhlIGxhdGVzdCBpbnRlcm5hbCBvYnNlcnZhYmxlcyBpbnRvIHRoZSBvdXRwdXRcbiAgICAvLyBATk9USUNFIGFwcGxpZWQgYmVoYXZpb3VyIChvbiB0aGUgdmFsdWVzLCBub3QgdGhlIG9ic2VydmFibGUpIHdpbGwgZmlyZSBoZXJlXG4gICAgc3dpdGNoQWxsKCksXG4gICAgdGFwKCgpID0+IGNmZy53b3JrKCkpXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXh0KHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgIG9ic2VydmFibGVzU3ViamVjdC5uZXh0KHZhbHVlKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZSgpOiBTdWJzY3JpcHRpb24ge1xuICAgICAgcmV0dXJuIG9ic2VydmFibGVzJC5zdWJzY3JpYmUoKTtcbiAgICB9LFxuICB9IGFzIENkQXdhcmU8VSB8IHVuZGVmaW5lZCB8IG51bGw+O1xufVxuIl19