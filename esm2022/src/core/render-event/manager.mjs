import { Observable, pipe, ReplaySubject } from 'rxjs';
import { distinctUntilChanged, switchMap, tap } from 'rxjs/operators';
import { combineRenderEventHandlers } from './handlers';
import { fromPotentialObservable, } from '../potential-observable';
import { untracked } from '@angular/core';
export function createRenderEventManager(handlers) {
    const handleRenderEvent = combineRenderEventHandlers(handlers);
    const potentialObservable$ = new ReplaySubject(1);
    return {
        nextPotentialObservable(potentialObservable) {
            potentialObservable$.next(potentialObservable);
        },
        handlePotentialObservableChanges() {
            return potentialObservable$.pipe(distinctUntilChanged(), switchMapToRenderEvent(), distinctUntilChanged(renderEventComparator), tap(handleRenderEvent));
        },
    };
}
function switchMapToRenderEvent() {
    return pipe(switchMap((potentialObservable) => {
        const observable$ = fromPotentialObservable(potentialObservable);
        let reset = true;
        let synchronous = true;
        return new Observable((subscriber) => {
            const subscription = untracked(() => observable$.subscribe({
                next(value) {
                    subscriber.next({ type: 'next', value, reset, synchronous });
                    reset = false;
                },
                error(error) {
                    subscriber.next({ type: 'error', error, reset, synchronous });
                    reset = false;
                },
                complete() {
                    subscriber.next({ type: 'complete', reset, synchronous });
                    reset = false;
                },
            }));
            if (reset) {
                subscriber.next({ type: 'suspense', reset, synchronous: true });
                reset = false;
            }
            synchronous = false;
            return subscription;
        });
    }));
}
function renderEventComparator(previous, current) {
    if (previous.type !== current.type || previous.reset !== current.reset) {
        return false;
    }
    if (current.type === 'next') {
        return previous.value === current.value;
    }
    if (current.type === 'error') {
        return previous.error === current.error;
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL21vZHVsZXMvY29tcG9uZW50L3NyYy9jb3JlL3JlbmRlci1ldmVudC9tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN2RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXRFLE9BQU8sRUFBRSwwQkFBMEIsRUFBdUIsTUFBTSxZQUFZLENBQUM7QUFDN0UsT0FBTyxFQUNMLHVCQUF1QixHQUV4QixNQUFNLHlCQUF5QixDQUFDO0FBQ2pDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFTMUMsTUFBTSxVQUFVLHdCQUF3QixDQUN0QyxRQUE0RDtJQUU1RCxNQUFNLGlCQUFpQixHQUFHLDBCQUEwQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQy9ELE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxhQUFhLENBQUssQ0FBQyxDQUFDLENBQUM7SUFFdEQsT0FBTztRQUNMLHVCQUF1QixDQUFDLG1CQUFtQjtZQUN6QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUNqRCxDQUFDO1FBQ0QsZ0NBQWdDO1lBQzlCLE9BQU8sb0JBQW9CLENBQUMsSUFBSSxDQUM5QixvQkFBb0IsRUFBRSxFQUN0QixzQkFBc0IsRUFBRSxFQUN4QixvQkFBb0IsQ0FBQyxxQkFBcUIsQ0FBQyxFQUMzQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FDdkIsQ0FBQztRQUNKLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsc0JBQXNCO0lBRzdCLE9BQU8sSUFBSSxDQUNULFNBQVMsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLEVBQUU7UUFDaEMsTUFBTSxXQUFXLEdBQUcsdUJBQXVCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUNqRSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBRXZCLE9BQU8sSUFBSSxVQUFVLENBQ25CLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDYixNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQ2xDLFdBQVcsQ0FBQyxTQUFTLENBQUM7Z0JBQ3BCLElBQUksQ0FBQyxLQUFLO29CQUNSLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztvQkFDN0QsS0FBSyxHQUFHLEtBQUssQ0FBQztnQkFDaEIsQ0FBQztnQkFDRCxLQUFLLENBQUMsS0FBSztvQkFDVCxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7b0JBQzlELEtBQUssR0FBRyxLQUFLLENBQUM7Z0JBQ2hCLENBQUM7Z0JBQ0QsUUFBUTtvQkFDTixVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztvQkFDMUQsS0FBSyxHQUFHLEtBQUssQ0FBQztnQkFDaEIsQ0FBQzthQUNGLENBQUMsQ0FDSCxDQUFDO1lBRUYsSUFBSSxLQUFLLEVBQUU7Z0JBQ1QsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUNoRSxLQUFLLEdBQUcsS0FBSyxDQUFDO2FBQ2Y7WUFDRCxXQUFXLEdBQUcsS0FBSyxDQUFDO1lBRXBCLE9BQU8sWUFBWSxDQUFDO1FBQ3RCLENBQUMsQ0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQ0gsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLHFCQUFxQixDQUM1QixRQUF3QixFQUN4QixPQUF1QjtJQUV2QixJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsS0FBSyxLQUFLLE9BQU8sQ0FBQyxLQUFLLEVBQUU7UUFDdEUsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7UUFDM0IsT0FBUSxRQUErQixDQUFDLEtBQUssS0FBSyxPQUFPLENBQUMsS0FBSyxDQUFDO0tBQ2pFO0lBRUQsSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtRQUM1QixPQUFRLFFBQTZCLENBQUMsS0FBSyxLQUFLLE9BQU8sQ0FBQyxLQUFLLENBQUM7S0FDL0Q7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBwaXBlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc3dpdGNoTWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBFcnJvclJlbmRlckV2ZW50LCBOZXh0UmVuZGVyRXZlbnQsIFJlbmRlckV2ZW50IH0gZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHsgY29tYmluZVJlbmRlckV2ZW50SGFuZGxlcnMsIFJlbmRlckV2ZW50SGFuZGxlcnMgfSBmcm9tICcuL2hhbmRsZXJzJztcbmltcG9ydCB7XG4gIGZyb21Qb3RlbnRpYWxPYnNlcnZhYmxlLFxuICBQb3RlbnRpYWxPYnNlcnZhYmxlUmVzdWx0LFxufSBmcm9tICcuLi9wb3RlbnRpYWwtb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB1bnRyYWNrZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBSZW5kZXJFdmVudE1hbmFnZXI8UE8+IHtcbiAgbmV4dFBvdGVudGlhbE9ic2VydmFibGUocG90ZW50aWFsT2JzZXJ2YWJsZTogUE8pOiB2b2lkO1xuICBoYW5kbGVQb3RlbnRpYWxPYnNlcnZhYmxlQ2hhbmdlcygpOiBPYnNlcnZhYmxlPFxuICAgIFJlbmRlckV2ZW50PFBvdGVudGlhbE9ic2VydmFibGVSZXN1bHQ8UE8+PlxuICA+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVuZGVyRXZlbnRNYW5hZ2VyPFBPPihcbiAgaGFuZGxlcnM6IFJlbmRlckV2ZW50SGFuZGxlcnM8UG90ZW50aWFsT2JzZXJ2YWJsZVJlc3VsdDxQTz4+XG4pOiBSZW5kZXJFdmVudE1hbmFnZXI8UE8+IHtcbiAgY29uc3QgaGFuZGxlUmVuZGVyRXZlbnQgPSBjb21iaW5lUmVuZGVyRXZlbnRIYW5kbGVycyhoYW5kbGVycyk7XG4gIGNvbnN0IHBvdGVudGlhbE9ic2VydmFibGUkID0gbmV3IFJlcGxheVN1YmplY3Q8UE8+KDEpO1xuXG4gIHJldHVybiB7XG4gICAgbmV4dFBvdGVudGlhbE9ic2VydmFibGUocG90ZW50aWFsT2JzZXJ2YWJsZSkge1xuICAgICAgcG90ZW50aWFsT2JzZXJ2YWJsZSQubmV4dChwb3RlbnRpYWxPYnNlcnZhYmxlKTtcbiAgICB9LFxuICAgIGhhbmRsZVBvdGVudGlhbE9ic2VydmFibGVDaGFuZ2VzKCkge1xuICAgICAgcmV0dXJuIHBvdGVudGlhbE9ic2VydmFibGUkLnBpcGUoXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgIHN3aXRjaE1hcFRvUmVuZGVyRXZlbnQoKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQocmVuZGVyRXZlbnRDb21wYXJhdG9yKSxcbiAgICAgICAgdGFwKGhhbmRsZVJlbmRlckV2ZW50KVxuICAgICAgKTtcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBzd2l0Y2hNYXBUb1JlbmRlckV2ZW50PFBPPigpOiAoXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxQTz5cbikgPT4gT2JzZXJ2YWJsZTxSZW5kZXJFdmVudDxQb3RlbnRpYWxPYnNlcnZhYmxlUmVzdWx0PFBPPj4+IHtcbiAgcmV0dXJuIHBpcGUoXG4gICAgc3dpdGNoTWFwKChwb3RlbnRpYWxPYnNlcnZhYmxlKSA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZhYmxlJCA9IGZyb21Qb3RlbnRpYWxPYnNlcnZhYmxlKHBvdGVudGlhbE9ic2VydmFibGUpO1xuICAgICAgbGV0IHJlc2V0ID0gdHJ1ZTtcbiAgICAgIGxldCBzeW5jaHJvbm91cyA9IHRydWU7XG5cbiAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxSZW5kZXJFdmVudDxQb3RlbnRpYWxPYnNlcnZhYmxlUmVzdWx0PFBPPj4+KFxuICAgICAgICAoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHVudHJhY2tlZCgoKSA9PlxuICAgICAgICAgICAgb2JzZXJ2YWJsZSQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh7IHR5cGU6ICduZXh0JywgdmFsdWUsIHJlc2V0LCBzeW5jaHJvbm91cyB9KTtcbiAgICAgICAgICAgICAgICByZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlcnJvcihlcnJvcikge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh7IHR5cGU6ICdlcnJvcicsIGVycm9yLCByZXNldCwgc3luY2hyb25vdXMgfSk7XG4gICAgICAgICAgICAgICAgcmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHsgdHlwZTogJ2NvbXBsZXRlJywgcmVzZXQsIHN5bmNocm9ub3VzIH0pO1xuICAgICAgICAgICAgICAgIHJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh7IHR5cGU6ICdzdXNwZW5zZScsIHJlc2V0LCBzeW5jaHJvbm91czogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG5cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckV2ZW50Q29tcGFyYXRvcjxUPihcbiAgcHJldmlvdXM6IFJlbmRlckV2ZW50PFQ+LFxuICBjdXJyZW50OiBSZW5kZXJFdmVudDxUPlxuKTogYm9vbGVhbiB7XG4gIGlmIChwcmV2aW91cy50eXBlICE9PSBjdXJyZW50LnR5cGUgfHwgcHJldmlvdXMucmVzZXQgIT09IGN1cnJlbnQucmVzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY3VycmVudC50eXBlID09PSAnbmV4dCcpIHtcbiAgICByZXR1cm4gKHByZXZpb3VzIGFzIE5leHRSZW5kZXJFdmVudDxUPikudmFsdWUgPT09IGN1cnJlbnQudmFsdWU7XG4gIH1cblxuICBpZiAoY3VycmVudC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIChwcmV2aW91cyBhcyBFcnJvclJlbmRlckV2ZW50KS5lcnJvciA9PT0gY3VycmVudC5lcnJvcjtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIl19