{
  "version": 3,
  "sources": ["../../../../modules/component/src/core/zone-helpers.ts", "../../../../modules/component/src/core/tick-scheduler.ts", "../../../../modules/component/src/core/render-scheduler.ts", "../../../../modules/component/src/core/render-event/handlers.ts", "../../../../modules/component/src/core/potential-observable.ts", "../../../../modules/component/src/core/render-event/manager.ts", "../../../../modules/component/src/let/let.directive.ts", "../../../../modules/component/src/push/push.pipe.ts"],
  "sourcesContent": ["import { NgZone } from '@angular/core';\n\nexport function isNgZone(zone: unknown): zone is NgZone {\n  return zone instanceof NgZone;\n}\n", "import { ApplicationRef, inject, Injectable, NgZone } from '@angular/core';\nimport { isNgZone } from './zone-helpers';\n\n@Injectable({\n  providedIn: 'root',\n  useFactory: () => {\n    const zone = inject(NgZone);\n    return isNgZone(zone)\n      ? new NoopTickScheduler()\n      : inject(AnimationFrameTickScheduler);\n  },\n})\nexport abstract class TickScheduler {\n  abstract schedule(): void;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AnimationFrameTickScheduler extends TickScheduler {\n  private isScheduled = false;\n\n  constructor(private readonly appRef: ApplicationRef) {\n    super();\n  }\n\n  schedule(): void {\n    if (!this.isScheduled) {\n      this.isScheduled = true;\n      requestAnimationFrame(() => {\n        this.appRef.tick();\n        this.isScheduled = false;\n      });\n    }\n  }\n}\n\nexport class NoopTickScheduler extends TickScheduler {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  schedule(): void {}\n}\n", "import { ChangeDetectorRef, inject, Injectable } from '@angular/core';\nimport { TickScheduler } from './tick-scheduler';\n\n/**\n * Provides rendering functionality regardless of whether `zone.js` is present\n * or not. It must be provided at the component/directive level.\n *\n * @usageNotes\n *\n * ### Rerender zone-less app on route changes\n *\n * ```ts\n * @Component({\n *   selector: 'app-root',\n *   template: '<router-outlet>',\n *   // ðŸ‘‡ `RenderScheduler` is provided at the component level\n *   providers: [RenderScheduler],\n *   changeDetection: ChangeDetectionStrategy.OnPush,\n * })\n * export class AppComponent implements OnInit {\n *   constructor(\n *     private readonly router: Router,\n *     private readonly renderScheduler: RenderScheduler\n *   ) {}\n *\n *   ngOnInit(): void {\n *     this.router.events\n *       .pipe(filter((e) => e instanceof NavigationEnd))\n *       .subscribe(() => this.renderScheduler.schedule());\n *   }\n * }\n * ```\n *\n * ### Rerender component on interval\n *\n * ```ts\n * @Component({\n *   selector: 'app-interval',\n *   template: '{{ elapsedTime }}ms',\n *   // ðŸ‘‡ `RenderScheduler` is provided at the component level\n *   providers: [RenderScheduler],\n *   changeDetection: ChangeDetectionStrategy.OnPush,\n * })\n * export class IntervalComponent implements OnInit {\n *   elapsedTime = 0;\n *\n *   constructor(private readonly renderScheduler: RenderScheduler) {}\n *\n *   ngOnInit(): void {\n *     setInterval(() => {\n *       this.elapsedTime += 1000;\n *       this.renderScheduler.schedule();\n *     }, 1000);\n *   }\n * }\n * ```\n */\n@Injectable()\nexport class RenderScheduler {\n  constructor(\n    private readonly cdRef: ChangeDetectorRef,\n    private readonly tickScheduler: TickScheduler\n  ) {}\n\n  /**\n   * Marks component and its ancestors as dirty.\n   * It also schedules a new change detection cycle in zone-less mode.\n   */\n  schedule(): void {\n    this.cdRef.markForCheck();\n    this.tickScheduler.schedule();\n  }\n}\n\nexport function createRenderScheduler(): RenderScheduler {\n  return new RenderScheduler(inject(ChangeDetectorRef), inject(TickScheduler));\n}\n", "import {\n  CompleteRenderEvent,\n  ErrorRenderEvent,\n  NextRenderEvent,\n  RenderEvent,\n  SuspenseRenderEvent,\n} from './models';\n\nexport interface RenderEventHandlers<T> {\n  suspense?(event: SuspenseRenderEvent): void;\n  next?(event: NextRenderEvent<T>): void;\n  error?(event: ErrorRenderEvent): void;\n  complete?(event: CompleteRenderEvent): void;\n}\n\nexport function combineRenderEventHandlers<T>(\n  handlers: RenderEventHandlers<T>\n): (event: RenderEvent<T>) => void {\n  return (event) => handlers[event.type]?.(event as any);\n}\n", "import { combineLatest, from, isObservable, Observable } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\n\ntype Primitive = string | number | bigint | boolean | symbol | null | undefined;\n\ntype ObservableOrPromise<T> = Observable<T> | PromiseLike<T>;\n\ntype ObservableDictionary<PO> = Required<{\n  [Key in keyof PO]: Observable<unknown>;\n}>;\n\nexport type PotentialObservableResult<\n  PO,\n  ExtendedResult = never\n> = PO extends ObservableOrPromise<infer Result>\n  ? Result | ExtendedResult\n  : PO extends Primitive\n  ? PO\n  : keyof PO extends never\n  ? PO\n  : PO extends ObservableDictionary<PO>\n  ?\n      | {\n          [Key in keyof PO]: PO[Key] extends Observable<infer Value>\n            ? Value\n            : never;\n        }\n      | ExtendedResult\n  : PO;\n\nexport function fromPotentialObservable<PO>(\n  potentialObservable: PO\n): Observable<PotentialObservableResult<PO>> {\n  type Result = ReturnType<typeof fromPotentialObservable<PO>>;\n\n  if (isObservable(potentialObservable)) {\n    return potentialObservable as Result;\n  }\n\n  if (isObservableDictionary(potentialObservable)) {\n    return combineLatest(\n      toDistinctObsDictionary(potentialObservable)\n    ) as Result;\n  }\n\n  if (isPromiseLike(potentialObservable)) {\n    return from(potentialObservable) as Result;\n  }\n\n  return new Observable<PO>((subscriber) => {\n    subscriber.next(potentialObservable);\n  }) as Result;\n}\n\nfunction isPromiseLike(value: unknown): value is PromiseLike<unknown> {\n  return typeof (value as PromiseLike<unknown>)?.then === 'function';\n}\n\nfunction isObservableDictionary(\n  value: unknown\n): value is Record<string, Observable<unknown>> {\n  return (\n    isDictionary(value) &&\n    Object.keys(value).length > 0 &&\n    Object.values(value).every(isObservable)\n  );\n}\n\nfunction isDictionary(value: unknown): value is Record<string, unknown> {\n  return !!value && typeof value === 'object' && !Array.isArray(value);\n}\n\nfunction toDistinctObsDictionary<\n  OD extends Record<string, Observable<unknown>>\n>(obsDictionary: OD): OD {\n  return Object.keys(obsDictionary).reduce(\n    (acc, key) => ({\n      ...acc,\n      [key]: obsDictionary[key].pipe(distinctUntilChanged()),\n    }),\n    {} as OD\n  );\n}\n", "import { Observable, pipe, ReplaySubject } from 'rxjs';\nimport { distinctUntilChanged, switchMap, tap } from 'rxjs/operators';\nimport { ErrorRenderEvent, NextRenderEvent, RenderEvent } from './models';\nimport { combineRenderEventHandlers, RenderEventHandlers } from './handlers';\nimport {\n  fromPotentialObservable,\n  PotentialObservableResult,\n} from '../potential-observable';\nimport { untracked } from '@angular/core';\n\nexport interface RenderEventManager<PO> {\n  nextPotentialObservable(potentialObservable: PO): void;\n  handlePotentialObservableChanges(): Observable<\n    RenderEvent<PotentialObservableResult<PO>>\n  >;\n}\n\nexport function createRenderEventManager<PO>(\n  handlers: RenderEventHandlers<PotentialObservableResult<PO>>\n): RenderEventManager<PO> {\n  const handleRenderEvent = combineRenderEventHandlers(handlers);\n  const potentialObservable$ = new ReplaySubject<PO>(1);\n\n  return {\n    nextPotentialObservable(potentialObservable) {\n      potentialObservable$.next(potentialObservable);\n    },\n    handlePotentialObservableChanges() {\n      return potentialObservable$.pipe(\n        distinctUntilChanged(),\n        switchMapToRenderEvent(),\n        distinctUntilChanged(renderEventComparator),\n        tap(handleRenderEvent)\n      );\n    },\n  };\n}\n\nfunction switchMapToRenderEvent<PO>(): (\n  source: Observable<PO>\n) => Observable<RenderEvent<PotentialObservableResult<PO>>> {\n  return pipe(\n    switchMap((potentialObservable) => {\n      const observable$ = fromPotentialObservable(potentialObservable);\n      let reset = true;\n      let synchronous = true;\n\n      return new Observable<RenderEvent<PotentialObservableResult<PO>>>(\n        (subscriber) => {\n          const subscription = untracked(() =>\n            observable$.subscribe({\n              next(value) {\n                subscriber.next({ type: 'next', value, reset, synchronous });\n                reset = false;\n              },\n              error(error) {\n                subscriber.next({ type: 'error', error, reset, synchronous });\n                reset = false;\n              },\n              complete() {\n                subscriber.next({ type: 'complete', reset, synchronous });\n                reset = false;\n              },\n            })\n          );\n\n          if (reset) {\n            subscriber.next({ type: 'suspense', reset, synchronous: true });\n            reset = false;\n          }\n          synchronous = false;\n\n          return subscription;\n        }\n      );\n    })\n  );\n}\n\nfunction renderEventComparator<T>(\n  previous: RenderEvent<T>,\n  current: RenderEvent<T>\n): boolean {\n  if (previous.type !== current.type || previous.reset !== current.reset) {\n    return false;\n  }\n\n  if (current.type === 'next') {\n    return (previous as NextRenderEvent<T>).value === current.value;\n  }\n\n  if (current.type === 'error') {\n    return (previous as ErrorRenderEvent).error === current.error;\n  }\n\n  return true;\n}\n", "import {\n  Directive,\n  ErrorHandler,\n  Input,\n  OnDestroy,\n  OnInit,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { PotentialObservableResult } from '../core/potential-observable';\nimport { RenderScheduler } from '../core/render-scheduler';\nimport { createRenderEventManager } from '../core/render-event/manager';\n\ntype LetViewContextValue<PO> = PotentialObservableResult<PO>;\n\nexport interface LetViewContext<PO> {\n  /**\n   * using `$implicit` to enable `let` syntax: `*ngrxLet=\"obs$; let o\"`\n   */\n  $implicit: LetViewContextValue<PO>;\n  /**\n   * using `ngrxLet` to enable `as` syntax: `*ngrxLet=\"obs$ as o\"`\n   */\n  ngrxLet: LetViewContextValue<PO>;\n  /**\n   * `*ngrxLet=\"obs$; let e = error\"` or `*ngrxLet=\"obs$; error as e\"`\n   */\n  error: any;\n  /**\n   * `*ngrxLet=\"obs$; let c = complete\"` or `*ngrxLet=\"obs$; complete as c\"`\n   */\n  complete: boolean;\n}\n\n/**\n *\n * @description\n *\n * The `*ngrxLet` directive serves a convenient way of binding observables to a view context\n * (DOM element's scope). It also helps with several internal processing under the hood.\n *\n * @usageNotes\n *\n * ### Displaying Observable Values\n *\n * ```html\n * <ng-container *ngrxLet=\"number$ as n\">\n *   <app-number [number]=\"n\"></app-number>\n * </ng-container>\n *\n * <ng-container *ngrxLet=\"number$; let n\">\n *   <app-number [number]=\"n\"></app-number>\n * </ng-container>\n * ```\n *\n * ### Tracking Different Observable Events\n *\n * ```html\n * <ng-container *ngrxLet=\"number$ as n; error as e; complete as c\">\n *   <app-number [number]=\"n\" *ngIf=\"!e && !c\">\n *   </app-number>\n *\n *   <p *ngIf=\"e\">There is an error: {{ e }}</p>\n *   <p *ngIf=\"c\">Observable is completed.</p>\n * </ng-container>\n * ```\n *\n * ### Combining Multiple Observables\n *\n * ```html\n * <ng-container *ngrxLet=\"{ users: users$, query: query$ } as vm\">\n *   <app-search-bar [query]=\"vm.query\"></app-search-bar>\n *   <app-user-list [users]=\"vm.users\"></app-user-list>\n * </ng-container>\n * ```\n *\n * ### Using Suspense Template\n *\n * ```html\n * <ng-container *ngrxLet=\"number$ as n; suspenseTpl: loading\">\n *   <app-number [number]=\"n\"></app-number>\n * </ng-container>\n *\n * <ng-template #loading>\n *   <p>Loading...</p>\n * </ng-template>\n * ```\n *\n * ### Using Aliases for Non-Observable Values\n *\n * ```html\n * <ng-container *ngrxLet=\"userForm.controls.email as email\">\n *   <input type=\"text\" [formControl]=\"email\" />\n *\n *   <ng-container *ngIf=\"email.errors && (email.touched || email.dirty)\">\n *     <p *ngIf=\"email.errors.required\">This field is required.</p>\n *     <p *ngIf=\"email.errors.email\">This field must be an email.</p>\n *   </ng-container>\n * </ng-container>\n * ```\n *\n * @publicApi\n */\n@Directive({\n  standalone: true,\n  selector: '[ngrxLet]',\n  providers: [RenderScheduler],\n})\nexport class LetDirective<PO> implements OnInit, OnDestroy {\n  private isMainViewCreated = false;\n  private isSuspenseViewCreated = false;\n  private readonly viewContext: LetViewContext<PO | undefined> = {\n    $implicit: undefined,\n    ngrxLet: undefined,\n    error: undefined,\n    complete: false,\n  };\n  private readonly renderEventManager = createRenderEventManager<PO>({\n    suspense: () => {\n      this.viewContext.$implicit = undefined;\n      this.viewContext.ngrxLet = undefined;\n      this.viewContext.error = undefined;\n      this.viewContext.complete = false;\n\n      this.renderSuspenseView();\n    },\n    next: (event) => {\n      this.viewContext.$implicit = event.value;\n      this.viewContext.ngrxLet = event.value;\n\n      if (event.reset) {\n        this.viewContext.error = undefined;\n        this.viewContext.complete = false;\n      }\n\n      this.renderMainView(event.synchronous);\n    },\n    error: (event) => {\n      this.viewContext.error = event.error;\n\n      if (event.reset) {\n        this.viewContext.$implicit = undefined;\n        this.viewContext.ngrxLet = undefined;\n        this.viewContext.complete = false;\n      }\n\n      this.renderMainView(event.synchronous);\n      this.errorHandler.handleError(event.error);\n    },\n    complete: (event) => {\n      this.viewContext.complete = true;\n\n      if (event.reset) {\n        this.viewContext.$implicit = undefined;\n        this.viewContext.ngrxLet = undefined;\n        this.viewContext.error = undefined;\n      }\n\n      this.renderMainView(event.synchronous);\n    },\n  });\n  private readonly subscription = new Subscription();\n\n  @Input()\n  set ngrxLet(potentialObservable: PO) {\n    this.renderEventManager.nextPotentialObservable(potentialObservable);\n  }\n\n  @Input('ngrxLetSuspenseTpl') suspenseTemplateRef?: TemplateRef<unknown>;\n\n  constructor(\n    private readonly mainTemplateRef: TemplateRef<\n      LetViewContext<PO | undefined>\n    >,\n    private readonly viewContainerRef: ViewContainerRef,\n    private readonly errorHandler: ErrorHandler,\n    private readonly renderScheduler: RenderScheduler\n  ) {}\n\n  static ngTemplateContextGuard<PO>(\n    dir: LetDirective<PO>,\n    ctx: unknown\n  ): ctx is LetViewContext<PO> {\n    return true;\n  }\n\n  ngOnInit(): void {\n    this.subscription.add(\n      this.renderEventManager.handlePotentialObservableChanges().subscribe()\n    );\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n  }\n\n  private renderMainView(isSyncEvent: boolean): void {\n    if (this.isSuspenseViewCreated) {\n      this.isSuspenseViewCreated = false;\n      this.viewContainerRef.clear();\n    }\n\n    if (!this.isMainViewCreated) {\n      this.isMainViewCreated = true;\n      this.viewContainerRef.createEmbeddedView(\n        this.mainTemplateRef,\n        this.viewContext\n      );\n    }\n\n    if (!isSyncEvent) {\n      this.renderScheduler.schedule();\n    }\n  }\n\n  private renderSuspenseView(): void {\n    if (this.isMainViewCreated) {\n      this.isMainViewCreated = false;\n      this.viewContainerRef.clear();\n    }\n\n    if (this.suspenseTemplateRef && !this.isSuspenseViewCreated) {\n      this.isSuspenseViewCreated = true;\n      this.viewContainerRef.createEmbeddedView(this.suspenseTemplateRef);\n    }\n  }\n}\n", "import { ErrorHandler, OnDestroy, Pipe, PipeTransform } from '@angular/core';\nimport { Unsubscribable } from 'rxjs';\nimport { PotentialObservableResult } from '../core/potential-observable';\nimport { createRenderScheduler } from '../core/render-scheduler';\nimport { createRenderEventManager } from '../core/render-event/manager';\n\ntype PushPipeResult<PO> = PotentialObservableResult<PO, undefined>;\n\n/**\n * @description\n *\n * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n * It contains intelligent handling of change detection to enable us\n * running in zone-full as well as zone-less mode without any changes to the code.\n *\n * @usageNotes\n *\n * ### Displaying Observable Values\n *\n * ```html\n * <p>{{ number$ | ngrxPush }}</p>\n *\n * <ng-container *ngIf=\"number$ | ngrxPush as n\">{{ n }}</ng-container>\n *\n * <app-number [number]=\"number$ | ngrxPush\"></app-number>\n * ```\n *\n * ### Combining Multiple Observables\n *\n * ```html\n * <code>\n *   {{ { users: users$, query: query$ } | ngrxPush | json }}\n * </code>\n * ```\n *\n * @publicApi\n */\n@Pipe({\n  standalone: true,\n  name: 'ngrxPush',\n  pure: false,\n})\nexport class PushPipe implements PipeTransform, OnDestroy {\n  private renderedValue: unknown;\n  private readonly renderScheduler = createRenderScheduler();\n  private readonly renderEventManager = createRenderEventManager({\n    suspense: (event) => this.setRenderedValue(undefined, event.synchronous),\n    next: (event) => this.setRenderedValue(event.value, event.synchronous),\n    error: (event) => {\n      if (event.reset) {\n        this.setRenderedValue(undefined, event.synchronous);\n      }\n      this.errorHandler.handleError(event.error);\n    },\n    complete: (event) => {\n      if (event.reset) {\n        this.setRenderedValue(undefined, event.synchronous);\n      }\n    },\n  });\n  private readonly subscription: Unsubscribable;\n\n  constructor(private readonly errorHandler: ErrorHandler) {\n    this.subscription = this.renderEventManager\n      .handlePotentialObservableChanges()\n      .subscribe();\n  }\n\n  transform<PO>(potentialObservable: PO): PushPipeResult<PO> {\n    this.renderEventManager.nextPotentialObservable(potentialObservable);\n    return this.renderedValue as PushPipeResult<PO>;\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n  }\n\n  private setRenderedValue(value: unknown, isSyncEvent: boolean): void {\n    if (value !== this.renderedValue) {\n      this.renderedValue = value;\n\n      if (!isSyncEvent) {\n        this.renderScheduler.schedule();\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["NgZone", "inject", "Injectable", "Observable", "distinctUntilChanged", "i0"]
}
