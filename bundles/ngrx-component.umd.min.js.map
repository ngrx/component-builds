{"version":3,"sources":["ng://@ngrx/component/src/core/utils/is-ivy.ts","ng://@ngrx/component/src/core/utils/get-global-this.ts","ng://@ngrx/component/src/core/utils/has-zone.ts","ng://@ngrx/component/src/core/cd-aware/cd-aware_creator.ts","ng://@ngrx/component/src/core/cd-aware/get-change-detection-handling.ts","ng://@ngrx/component/src/core/projections/toObservableValue.ts","ng://@ngrx/component/src/push/push.pipe.ts","ng://@ngrx/component/src/let/let.directive.ts","ng://@ngrx/component/src/reactive-component.module.ts"],"names":["isIvy","ng","undefined","probe","hasZone","z","constructor","name","setUpWork","cfg","ngZone","cdRef","render","markDirty","detectChanges","markForCheck","bind","context","createCdAware","observablesSubject","Subject","observables$","pipe","distinctUntilChanged","map","v","p","from","of","tap","resetContextObserver","next","work","value$","updateViewContextObserver","configurableBehaviour","switchAll","value","subscribe","PushPipe","_this","this","configSubject","config$","asObservable","renderedValue","o$","withLatestFrom","_a","_b","__read","cdAware","subscription","prototype","transform","potentialObservable","config","optimized","ngOnDestroy","unsubscribe","Pipe","args","pure","ChangeDetectorRef","NgZone","LetDirective","templateRef","viewContainerRef","ViewContext","$implicit","ngrxLet","$error","$complete","ReplaySubject","filter","startWith","embeddedView","createEmbeddedView","error","complete","__read$1","catchError","e","EMPTY","ngTemplateContextGuard","dir","ctx","Object","defineProperty","clear","Directive","selector","TemplateRef","ViewContainerRef","Input","DECLARATIONS","EXPORTS","ReactiveComponentModule","NgModule","declarations","exports"],"mappings":"8YA+BgBA,QACRC,GCfE,YAAW,MAAyB,QDeZA,GAKhC,YACSC,IAAPD,QAGaC,IAAbD,EAAGE,eE1BSC,EAAQC,GACtB,MAA8B,eAAvBA,EAAEC,YAAYC,cCWPC,EAAUC,OChBxBC,EACAC,EDgBMC,GCjBNF,EDkBED,EAAIC,OCjBNC,EDkBEF,EAAIE,MChBFX,IACKI,EAAQM,GAAUG,EAAAA,WAAYC,EAAAA,eAE9BV,EAAQM,GACXC,EAAMI,aAAaC,KAAKL,GACxBA,EAAMG,cAAcE,KAAKL,IDa/B,OAAA,WAAa,OAAAC,EAAOH,EAAIQ,oBAYVC,EAAiBT,OAQzBU,EAAqB,IAAIC,EAAAA,QAGzBC,EAEFF,EAAmBG,KACrBC,EAAAA,uBAEAC,EAAAA,KAAG,SAAEC,GAAM,OE3CsBC,EF2CJD,GE1CpBE,EAAAA,KAAKD,GAAKE,EAAAA,GAAGF,OADWA,KF4CjCG,EAAAA,KAAG,SAAEJ,GACHhB,EAAIqB,qBAAqBC,KAAKN,GAC9BhB,EAAIuB,UAENR,EAAAA,KAAG,SAACS,GACF,OAAAA,EAAOX,KACLC,EAAAA,uBACAM,EAAAA,IAAIpB,EAAIyB,+BAGZzB,EAAI0B,sBACJC,EAAAA,YACAP,EAAAA,KAAG,WAAO,OAAApB,EAAIuB,WAGhB,MAAA,CACED,KAAA,SAAKM,GACHlB,EAAmBY,KAAKM,IAE1BC,UAAA,WACE,OAAOjB,EAAaiB,4UGcxB,SAAAC,EAAY5B,EAA0BD,GAAtC,IAAA8B,EAAAC,KAzBiBA,KAAAC,cAAgB,IAAItB,EAAAA,QACpBqB,KAAAE,QAAUF,KAAKC,cAC7BE,eACAtB,KAAKC,EAAAA,wBAISkB,KAAAP,0BAEb,CACFH,KAAI,SAAGM,GAAgC,OAACG,EAAKK,cAAgBR,IAE9CI,KAAAX,qBAA8C,CAC7DC,KAAI,SAAGM,GAAmB,OAACG,EAAKK,mBAAgB3C,IAEjCuC,KAAAN,sBAAqB,SACpCW,GAEA,OAAAA,EAAGxB,KACDyB,EAAAA,eAAeP,EAAKG,SACpBnB,EAAAA,KAAG,SAAEwB,OAAAC,EAAAC,EAAAF,EAAA,GAACf,EAAAgB,EAAA,GAAQA,EAAA,GACZ,OAAOhB,EAAOX,YAKlBmB,KAAKU,QAAUjC,EAAiB,CAC9Bc,KAAMxB,EAAU,CACdE,OAAMA,EACNC,MAAKA,EACLM,QAAS,EAAsCA,UAEjDiB,0BAA2BO,KAAKP,0BAChCJ,qBAAsBW,KAAKX,qBAC3BK,sBAAuBM,KAAKN,wBAE9BM,KAAKW,aAAeX,KAAKU,QAAQb,YAqBrC,OAZEC,EAAAc,UAAAC,UAAA,SACEC,EACAC,GAIA,YAJA,IAAAA,IAAAA,EAAA,CAA2BC,WAAW,IAEtChB,KAAKC,cAAcX,KAAKyB,GACxBf,KAAKU,QAAQpB,KAAKwB,GACXd,KAAKI,eAGdN,EAAAc,UAAAK,YAAA,WACEjB,KAAKW,aAAaO,mCA3DrBC,EAAAA,KAAIC,KAAA,CAAC,CAAEtD,KAAM,WAAYuD,MAAM,+CAjE9BC,EAAAA,yBAEAC,EAAAA,UA4HFzB,uUCmEE,SAAA0B,EACEtD,EACAD,EACiBwD,EACAC,GAJnB,IAAA3B,EAAAC,KAGmBA,KAAAyB,YAAAA,EACAzB,KAAA0B,iBAAAA,EAnFF1B,KAAA2B,YAAoD,CACnEC,eAAWnE,EACXoE,aAASpE,EACTqE,QAAQ,EACRC,WAAW,GAGI/B,KAAAC,cAAgB,IAAI+B,EAAAA,cACpBhC,KAAAE,QAAUF,KAAKC,cAAcpB,KAC5CoD,EAAAA,QAAM,SAACjD,GAAK,OAAAA,MAAAA,KACZF,EAAAA,uBACAoD,EAAAA,UAAU,CAAElB,WAAW,KAKRhB,KAAAX,qBAA8C,CAC7DC,KAAI,WACES,EAAKoC,eACPpC,EAAK4B,YAAYC,eAAYnE,EAC7BsC,EAAK4B,YAAYE,aAAUpE,EAC3BsC,EAAK4B,YAAYG,QAAS,EAC1B/B,EAAK4B,YAAYI,WAAY,KAIlB/B,KAAAP,0BAEb,CACFH,KAAI,SAAGM,GACAG,EAAKoC,cACRpC,EAAKqC,qBAEPrC,EAAK4B,YAAYC,UAAYhC,EAC7BG,EAAK4B,YAAYE,QAAUjC,GAE7ByC,MAAK,SAAGA,GACDtC,EAAKoC,cACRpC,EAAKqC,qBAEPrC,EAAK4B,YAAYG,QAAS,GAE5BQ,SAAQ,WACDvC,EAAKoC,cACRpC,EAAKqC,qBAEPrC,EAAK4B,YAAYI,WAAY,IAWhB/B,KAAAN,sBAAqB,SACpCW,GAEA,OAAAA,EAAGxB,KACDyB,EAAAA,eAAeP,EAAKG,SACpBnB,EAAAA,KAAG,SAAEwB,OAAAC,EAAA+B,EAAAhC,EAAA,GAACf,EAAAgB,EAAA,GAAQA,EAAA,GACZ,OAAOhB,EAAOX,KAAK2D,EAAAA,YAAU,SAACC,GAAK,OAAAC,EAAAA,eAsBvC1C,KAAKU,QAAUjC,EAAiB,CAC9Bc,KAAMxB,EAAU,CACdG,MAAKA,EACLD,OAAMA,EACNO,QAAS,EAAsCA,UAEjDa,qBAAsBW,KAAKX,qBAC3BI,0BAA2BO,KAAKP,0BAChCC,sBAAuBM,KAAKN,wBAE9BM,KAAKW,aAAeX,KAAKU,QAAQb,YAcrC,OA3DS2B,EAAAmB,uBAAP,SACEC,EACAC,GAEA,OAAO,GAaTC,OAAAC,eACIvB,EAAAZ,UAAA,UAAO,KADX,SAEEE,GAEAd,KAAKU,QAAQpB,KAAKwB,oCAGpBgC,OAAAC,eACIvB,EAAAZ,UAAA,gBAAa,KADjB,SACkBG,GAChBf,KAAKC,cAAcX,KAAKyB,GAAU,CAAEC,WAAW,qCAsBjDQ,EAAAZ,UAAAwB,mBAAA,WACEpC,KAAKmC,aAAenC,KAAK0B,iBAAiBU,mBACxCpC,KAAKyB,YACLzB,KAAK2B,cAITH,EAAAZ,UAAAK,YAAA,WACEjB,KAAKW,aAAaO,cAClBlB,KAAK0B,iBAAiBsB,6BA9GzBC,EAAAA,UAAS7B,KAAA,CAAC,CAAE8B,SAAU,yDA/GrB5B,EAAAA,yBAIAC,EAAAA,cAEA4B,EAAAA,mBAEAC,EAAAA,qDA6KCC,EAAAA,6BAOAA,EAAAA,SAmCH7B,SC5NM8B,EAAe,CAAC9B,EAAc1B,GAC9ByD,EAAU,CAACD,gBAEjB,SAAAE,KAIsC,2BAJrCC,EAAAA,SAAQrC,KAAA,CAAC,CACRsC,aAAc,CAACJ,GACfK,QAAS,CAACJ,OAE0BC","sourcesContent":["import { getGlobalThis } from './get-global-this';\n\n/**\n * @description\n *\n * Determines if the application runs with ivy or not (ViewEngine)\n *\n * @usageNotes\n *\n * The function can be just imported and used everywhere.\n *\n * ```ts\n * import { isIvy } from `utils/is-ivy`;\n *\n * console.log(isIvy());  // true or false\n * ```\n *\n * The determination if an application runs with Ivy or not is done by following table:\n *\n * **Table for ng global presence in ViewEngine and Ivy for prod/dev modes**\n *\n *  | render   | ViewEngine | ViewEngine | Ivy       | Ivy       |\n *  | -------- | ---------- | ---------- | --------- | --------  |\n *  | mode     | prod       | dev        | prod      | dev       |\n *  | ng       | present    | present    | undefined | present   |\n *  | ng.probe | present    | present    | undefined | undefined |\n *\n *  > So for Ivy we need to make sure that ng is undefined or,\n *  > in case of dev environment, ng.probe is undefined\n *\n */\nexport function isIvy(): boolean {\n  const ng: any = getGlobalThis().ng;\n\n  // Is the global ng object is unavailable?\n  // ng === undefined in Ivy production mode\n  // View Engine has the ng object both in development mode and production mode.\n  return (\n    ng === undefined ||\n    // in case we are in dev mode in ivy\n    // `probe` property is available on ng object we use View Engine.\n    ng.probe === undefined\n  );\n}\n","/**\n * @description\n *\n * This function returns a reference to globalThis in the following environments:\n * - Browser\n * - SSR (Server Side Rendering)\n * - Tests\n *\n * The function can be just imported and used everywhere.\n *\n * ```ts\n * import { getGlobalThis } from `utils/get-global-this`;\n *\n * console.log(getGlobalThis());\n * ```\n */\nexport function getGlobalThis(): any {\n  return ((globalThis as any) || (self as any) || (window as any)) as any;\n}\n","import { NgZone } from '@angular/core';\n\n/**\n * @description\n *\n * Determines if the application uses `NgZone` or `NgNoopZone` as ngZone service instance.\n *\n * The function can be just imported and used everywhere.\n *\n * ```ts\n * import { hasZone } from `utils/has-zone`;\n *\n * console.log(hasZone());\n * ```\n */\nexport function hasZone(z: NgZone): boolean {\n  return z.constructor.name !== 'NoopNgZone';\n}\n","import { ChangeDetectorRef, NgZone } from '@angular/core';\nimport {\n  NextObserver,\n  Observable,\n  PartialObserver,\n  Subject,\n  Subscribable,\n  Subscription,\n} from 'rxjs';\nimport { distinctUntilChanged, map, switchAll, tap } from 'rxjs/operators';\nimport { toObservableValue } from '../projections';\nimport { getChangeDetectionHandler } from './get-change-detection-handling';\n\nexport interface CoalescingConfig {\n  optimized: boolean;\n}\n\nexport interface CdAware<U> extends Subscribable<U> {\n  next: (value: Observable<U> | Promise<U> | null | undefined) => void;\n}\n\nexport interface WorkConfig {\n  context: any;\n  ngZone: NgZone;\n  cdRef: ChangeDetectorRef;\n}\n\nexport function setUpWork(cfg: WorkConfig): () => void {\n  const render: (component?: any) => void = getChangeDetectionHandler(\n    cfg.ngZone,\n    cfg.cdRef\n  );\n  return () => render(cfg.context);\n}\n\n/**\n * class CdAware\n *\n * @description\n * This abstract class holds all the shared logic for the push pipe and the let directive\n * responsible for change detection\n * If you extend this class you need to implement how the update of the rendered value happens.\n * Also custom behaviour is something you need to implement in the extending class\n */\nexport function createCdAware<U>(cfg: {\n  work: () => void;\n  resetContextObserver: NextObserver<unknown>;\n  configurableBehaviour: (\n    o: Observable<Observable<U | null | undefined>>\n  ) => Observable<Observable<U | null | undefined>>;\n  updateViewContextObserver: PartialObserver<U | null | undefined>;\n}): CdAware<U | undefined | null> {\n  const observablesSubject = new Subject<\n    Observable<U> | Promise<U> | null | undefined\n  >();\n  const observables$: Observable<\n    U | undefined | null\n  > = observablesSubject.pipe(\n    distinctUntilChanged(),\n    // Try to convert it to values, throw if not possible\n    map((v) => toObservableValue(v)),\n    tap((v: any) => {\n      cfg.resetContextObserver.next(v);\n      cfg.work();\n    }),\n    map(value$ =>\n      value$.pipe(\n        distinctUntilChanged(),\n        tap(cfg.updateViewContextObserver)\n      )\n    ),\n    cfg.configurableBehaviour,\n    switchAll(),\n    tap(() => cfg.work())\n  );\n\n  return {\n    next(value: any): void {\n      observablesSubject.next(value);\n    },\n    subscribe(): Subscription {\n      return observables$.subscribe();\n    },\n  } as CdAware<U | undefined | null>;\n}\n","import {\n  ChangeDetectorRef,\n  NgZone,\n  ɵdetectChanges as detectChanges,\n  ɵmarkDirty as markDirty,\n} from '@angular/core';\n\nimport { isIvy } from '../utils/is-ivy';\nimport { hasZone } from '../utils/has-zone';\n\nexport function getChangeDetectionHandler(\n  ngZone: NgZone,\n  cdRef: ChangeDetectorRef\n): <T>(component?: T) => void {\n  if (isIvy()) {\n    return hasZone(ngZone) ? markDirty : detectChanges;\n  } else {\n    return hasZone(ngZone)\n      ? cdRef.markForCheck.bind(cdRef)\n      : cdRef.detectChanges.bind(cdRef);\n  }\n}\n","import { from, of, Observable, ObservableInput } from 'rxjs';\n\n/**\n * @description\n *\n * This operator ensures the passed value is of the right type for `CdAware`.\n * It takes `null`, `undefined` or `Observable<T>` and returns `Observable<null, undefined, T>`.\n * Every other value throws an error.\n *\n * ```ts\n * import { toObservableValue } from `projections/toObservableValue`;\n *\n * const toObservableValue()\n *  .pipe(switchAll())\n *  .subscribe((n) => console.log(n););\n * ```\n */\nexport function toObservableValue<T>(p: any): Observable<T | undefined | null> {\n  return p ? from(p) : of(p);\n}\n","import {\n  ChangeDetectorRef,\n  EmbeddedViewRef,\n  NgZone,\n  OnDestroy,\n  Pipe,\n  PipeTransform,\n  Type,\n} from '@angular/core';\nimport {\n  NextObserver,\n  Observable,\n  PartialObserver,\n  Subject,\n  Unsubscribable,\n} from 'rxjs';\nimport { distinctUntilChanged, map, withLatestFrom } from 'rxjs/operators';\nimport {\n  CdAware,\n  CoalescingConfig as PushPipeConfig,\n  createCdAware,\n  setUpWork,\n} from '../core';\n\n/**\n * @Pipe PushPipe\n *\n * @description\n *\n * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n * It contains intelligent handling of change detection to enable us\n * running in zone-full as well as zone-less mode without any changes to the code.\n *\n * The current way of binding an observable to the view looks like that:\n *  ```html\n *  {{observable$ | async}}\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | async\"></component>\n * ```\n *\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked components.\n *\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\n *\n * `ngrxPush` pipe solves that problem.\n *\n * Included Features:\n *  - Take observables or promises, retrieve their values and render the value to the template\n *  - Handling null and undefined values in a clean unified/structured way\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\n *  - Distinct same values in a row to increase performance\n *  - Coalescing of change detection calls to boost performance\n *\n * @usageNotes\n *\n * `ngrxPush` pipe solves that problem. It can be used like shown here:\n * ```html\n * {{observable$ | ngrxPush}}\n * <ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | ngrxPush\"></component>\n * ```\n *\n * @publicApi\n */\n@Pipe({ name: 'ngrxPush', pure: false })\nexport class PushPipe<S> implements PipeTransform, OnDestroy {\n  private renderedValue: S | null | undefined;\n\n  private readonly configSubject = new Subject<PushPipeConfig>();\n  private readonly config$ = this.configSubject\n    .asObservable()\n    .pipe(distinctUntilChanged());\n\n  private readonly subscription: Unsubscribable;\n  private readonly cdAware: CdAware<S | null | undefined>;\n  private readonly updateViewContextObserver: PartialObserver<\n    S | null | undefined\n  > = {\n    next: (value: S | null | undefined) => (this.renderedValue = value),\n  };\n  private readonly resetContextObserver: NextObserver<unknown> = {\n    next: (value: unknown) => (this.renderedValue = undefined),\n  };\n  private readonly configurableBehaviour = <T>(\n    o$: Observable<Observable<T>>\n  ): Observable<Observable<T>> =>\n    o$.pipe(\n      withLatestFrom(this.config$),\n      map(([value$, config]) => {\n        return value$.pipe();\n      })\n    );\n\n  constructor(cdRef: ChangeDetectorRef, ngZone: NgZone) {\n    this.cdAware = createCdAware<S>({\n      work: setUpWork({\n        ngZone,\n        cdRef,\n        context: (cdRef as EmbeddedViewRef<Type<any>>).context,\n      }),\n      updateViewContextObserver: this.updateViewContextObserver,\n      resetContextObserver: this.resetContextObserver,\n      configurableBehaviour: this.configurableBehaviour,\n    });\n    this.subscription = this.cdAware.subscribe();\n  }\n\n  transform(potentialObservable: null, config?: PushPipeConfig): null;\n  transform(potentialObservable: undefined, config?: PushPipeConfig): undefined;\n  transform(\n    potentialObservable: Observable<S> | Promise<S>,\n    config?: PushPipeConfig\n  ): S;\n  transform(\n    potentialObservable: Observable<S> | Promise<S> | null | undefined,\n    config: PushPipeConfig = { optimized: true }\n  ): S | null | undefined {\n    this.configSubject.next(config);\n    this.cdAware.next(potentialObservable);\n    return this.renderedValue;\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n  }\n}\n","import {\n  ChangeDetectorRef,\n  Directive,\n  EmbeddedViewRef,\n  Input,\n  NgZone,\n  OnDestroy,\n  TemplateRef,\n  Type,\n  ViewContainerRef,\n} from '@angular/core';\n\nimport {\n  EMPTY,\n  NextObserver,\n  Observable,\n  PartialObserver,\n  ReplaySubject,\n  Unsubscribable,\n} from 'rxjs';\nimport {\n  catchError,\n  distinctUntilChanged,\n  filter,\n  map,\n  startWith,\n  withLatestFrom,\n} from 'rxjs/operators';\nimport {\n  CdAware,\n  CoalescingConfig as NgRxLetConfig,\n  createCdAware,\n  setUpWork,\n} from '../core';\n\nexport interface LetViewContext<T> {\n  // to enable `let` syntax we have to use $implicit (var; let v = var)\n  $implicit?: T;\n  // to enable `as` syntax we have to assign the directives selector (var as v)\n  ngrxLet?: T;\n  // set context var complete to true (var$; let e = $error)\n  $error?: boolean;\n  // set context var complete to true (var$; let c = $complete)\n  $complete?: boolean;\n}\n\n/**\n * @Directive LetDirective\n *\n * @description\n *\n * The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\n * It also helps with several internal processing under the hood.\n *\n * The current way of binding an observable to the view looks like that:\n * ```html\n * <ng-container *ngIf=\"observableNumber$ as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * <app-number-special [number]=\"n\">\n * </app-number-special>\n * </ng-container>\n *  ```\n *\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\n *\n * Included Features:\n * - binding is always present. (`*ngIf=\"truthy$\"`)\n * - it takes away the multiple usages of the `async` or `ngrxPush` pipe\n * - a unified/structured way of handling null and undefined\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ɵdetectChanges`)\n * - distinct same values in a row (distinctUntilChanged operator),\n *\n * @usageNotes\n *\n * The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template\n * `<ng-container *ngrxLet=\"observableNumber$ as c\"></ng-container>`\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$ as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n *\n * <ng-container *ngrxLet=\"observableNumber$; let n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n * ```\n *\n * In addition to that it provides us information from the whole observable context.\n * We can track the observables:\n * - next value\n * - error value\n * - complete state\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\n * </app-number>\n * <ng-container *ngIf=\"e\">\n * There is an error: {{e}}\n * </ng-container>\n * <ng-container *ngIf=\"c\">\n * Observable completed: {{c}}\n * </ng-container>\n * </ng-container>\n * ```\n *\n * @publicApi\n */\n@Directive({ selector: '[ngrxLet]' })\nexport class LetDirective<U> implements OnDestroy {\n  private embeddedView: any;\n  private readonly ViewContext: LetViewContext<U | undefined | null> = {\n    $implicit: undefined,\n    ngrxLet: undefined,\n    $error: false,\n    $complete: false,\n  };\n\n  private readonly configSubject = new ReplaySubject<NgRxLetConfig>();\n  private readonly config$ = this.configSubject.pipe(\n    filter(v => v !== undefined && v !== null),\n    distinctUntilChanged(),\n    startWith({ optimized: true })\n  );\n\n  protected readonly subscription: Unsubscribable;\n  private readonly cdAware: CdAware<U | null | undefined>;\n  private readonly resetContextObserver: NextObserver<unknown> = {\n    next: () => {\n      if (this.embeddedView) {\n        this.ViewContext.$implicit = undefined;\n        this.ViewContext.ngrxLet = undefined;\n        this.ViewContext.$error = false;\n        this.ViewContext.$complete = false;\n      }\n    },\n  };\n  private readonly updateViewContextObserver: PartialObserver<\n    U | null | undefined\n  > = {\n    next: (value: U | null | undefined) => {\n      if (!this.embeddedView) {\n        this.createEmbeddedView();\n      }\n      this.ViewContext.$implicit = value;\n      this.ViewContext.ngrxLet = value;\n    },\n    error: (error: Error) => {\n      if (!this.embeddedView) {\n        this.createEmbeddedView();\n      }\n      this.ViewContext.$error = true;\n    },\n    complete: () => {\n      if (!this.embeddedView) {\n        this.createEmbeddedView();\n      }\n      this.ViewContext.$complete = true;\n    },\n  };\n\n  static ngTemplateContextGuard<U>(\n    dir: LetDirective<U>,\n    ctx: unknown\n  ): ctx is LetViewContext<U> {\n    return true;\n  }\n\n  private readonly configurableBehaviour = <T>(\n    o$: Observable<Observable<T>>\n  ): Observable<Observable<T>> =>\n    o$.pipe(\n      withLatestFrom(this.config$),\n      map(([value$, config]) => {\n        return value$.pipe(catchError(e => EMPTY));\n      })\n    );\n\n  @Input()\n  set ngrxLet(\n    potentialObservable: Observable<U> | Promise<U> | null | undefined\n  ) {\n    this.cdAware.next(potentialObservable);\n  }\n\n  @Input()\n  set ngrxLetConfig(config: NgRxLetConfig) {\n    this.configSubject.next(config || { optimized: true });\n  }\n\n  constructor(\n    cdRef: ChangeDetectorRef,\n    ngZone: NgZone,\n    private readonly templateRef: TemplateRef<LetViewContext<U>>,\n    private readonly viewContainerRef: ViewContainerRef\n  ) {\n    this.cdAware = createCdAware<U>({\n      work: setUpWork({\n        cdRef,\n        ngZone,\n        context: (cdRef as EmbeddedViewRef<Type<any>>).context,\n      }),\n      resetContextObserver: this.resetContextObserver,\n      updateViewContextObserver: this.updateViewContextObserver,\n      configurableBehaviour: this.configurableBehaviour,\n    });\n    this.subscription = this.cdAware.subscribe();\n  }\n\n  createEmbeddedView() {\n    this.embeddedView = this.viewContainerRef.createEmbeddedView(\n      this.templateRef,\n      this.ViewContext\n    );\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n    this.viewContainerRef.clear();\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { LetDirective } from './let';\nimport { PushPipe } from './push';\n\nconst DECLARATIONS = [LetDirective, PushPipe];\nconst EXPORTS = [DECLARATIONS];\n\n@NgModule({\n  declarations: [DECLARATIONS],\n  exports: [EXPORTS],\n})\nexport class ReactiveComponentModule {}\n"]}