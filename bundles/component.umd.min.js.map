{"version":3,"sources":["modules/component/component.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ngrx","component","tslib","ng","core","rxjs","operators","this","hasZone","z","constructor","name","toObservableValue","p","of","from","setUpWork","cfg","render","getChangeDetectionHandler","ngZone","cdRef","isIvy","getGlobalThis","globalThis","window","undefined","probe","ɵmarkDirty","ɵdetectChanges","markForCheck","bind","detectChanges","context","createCdAware","observablesSubject","Subject","observables$","pipe","distinctUntilChanged","map","tap","v","resetContextObserver","next","work","value$","updateViewContextObserver","configurableBehaviour","switchAll","value","subscribe","PushPipe","_this","configSubject","config$","asObservable","renderedValue","o$","withLatestFrom","_a","__read","cdAware","subscription","prototype","transform","potentialObservable","config","optimized","ngOnDestroy","unsubscribe","__decorate","Pipe","pure","__metadata","ChangeDetectorRef","NgZone","LetDirective","templateRef","viewContainerRef","ViewContext","$implicit","ngrxLet","$error","$complete","ReplaySubject","filter","startWith","embeddedView","createEmbeddedView","error","complete","catchError","e","EMPTY","ngTemplateContextGuard","dir","ctx","Object","defineProperty","set","enumerable","configurable","clear","Input","Directive","selector","TemplateRef","ViewContainerRef","DECLARATIONS","ReactiveComponentModule","NgModule","declarations"],"mappings":"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","sourcesContent":["/**\n * @license NgRx 9.1.0+1.sha-6a18359\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/core'), require('rxjs'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@ngrx/component', ['exports', 'tslib', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ngrx = global.ngrx || {}, global.ngrx.component = {}), global.tslib, global.ng.core, global.rxjs, global.rxjs.operators));\n}(this, (function (exports, tslib, core, rxjs, operators) { 'use strict';\n\n    // Returns a reference to global thin\n    // - Browser\n    // - SSR\n    // - Tests\n    function getGlobalThis() {\n        return (globalThis || self || window);\n    }\n\n    // Table for ng global presence in ViewEngine and Ivy for prod/dev modes:\n    //\n    // | render     |  ViewEngine    |  ViewEngine    |      Ivy          |      Ivy          |\n    // | mode       |     prod       |      dev       |      prod         |      dev          |\n    // | ng         |     present    |     present    |     undefined     |     present       |\n    // | ng.probe   |     present    |     present    |     undefined     |     undefined     |\n    //\n    // So for Ivy we need to make sure that ng is undefined or,\n    // in case of dev environment, ng.probe is undefined\n    function isIvy() {\n        var ng = getGlobalThis().ng;\n        // Is the global ng object is unavailable?\n        // ng === undefined in Ivy production mode\n        // View Engine has the ng object both in development mode and production mode.\n        return (ng === undefined ||\n            // in case we are in dev mode in ivy\n            // `probe` property is available on ng object we use View Engine.\n            ng.probe === undefined);\n    }\n\n    function hasZone(z) {\n        return z.constructor.name !== 'NoopNgZone';\n    }\n\n    function getChangeDetectionHandler(ngZone, cdRef) {\n        if (isIvy()) {\n            return hasZone(ngZone) ? core.ɵmarkDirty : core.ɵdetectChanges;\n        }\n        else {\n            return hasZone(ngZone)\n                ? cdRef.markForCheck.bind(cdRef)\n                : cdRef.detectChanges.bind(cdRef);\n        }\n    }\n    function getDetectChanges(ngZone, cdRef) {\n        if (isIvy()) {\n            return !hasZone(ngZone) ? core.ɵdetectChanges : core.ɵmarkDirty;\n        }\n        else {\n            return hasZone(ngZone)\n                ? cdRef.markForCheck.bind(cdRef)\n                : cdRef.detectChanges.bind(cdRef);\n        }\n    }\n\n    function toObservableValue(p) {\n        return p == null ? rxjs.of(p) : rxjs.from(p);\n    }\n\n    function setUpWork(cfg) {\n        var render = getChangeDetectionHandler(cfg.ngZone, cfg.cdRef);\n        return function () { return render(cfg.context); };\n    }\n    /**\n     * class CdAware\n     *\n     * @description\n     * This abstract class holds all the shared logic for the push pipe and the let directive\n     * responsible for change detection\n     * If you extend this class you need to implement how the update of the rendered value happens.\n     * Also custom behaviour is something you need to implement in the extending class\n     */\n    function createCdAware(cfg) {\n        var observablesSubject = new rxjs.Subject();\n        // We have to defer the setup of observables$ until subscription as getConfigurableBehaviour is defined in the\n        // extending class. So getConfigurableBehaviour is not available in the abstract layer\n        var observables$ = observablesSubject.pipe(\n        // Ignore potential observables of the same instances\n        operators.distinctUntilChanged(), \n        // Try to convert it to values, throw if not possible\n        operators.map(toObservableValue), operators.tap(function (v) {\n            cfg.resetContextObserver.next(v);\n            cfg.work();\n        }), operators.map(function (value$) {\n            return value$.pipe(operators.distinctUntilChanged(), operators.tap(cfg.updateViewContextObserver));\n        }), \n        // e.g. coalescing\n        cfg.configurableBehaviour, \n        // Unsubscribe from previous observables\n        // Then flatten the latest internal observables into the output\n        // @NOTICE applied behaviour (on the values, not the observable) will fire here\n        operators.switchAll(), operators.tap(function () { return cfg.work(); }));\n        return {\n            next: function (value) {\n                observablesSubject.next(value);\n            },\n            subscribe: function () {\n                return observables$.subscribe();\n            },\n        };\n    }\n\n    /**\n     * @Pipe PushPipe\n     * @description\n     *\n     * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n     * It contains intelligent handling of change detection to enable us\n     * running in zone-full as well as zone-less mode without any changes to the code.\n     *\n     * The current way of binding an observable to the view looks like that:\n     *  ```html\n     *  {{observable$ | async}}\n     * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\n     * <component [value]=\"observable$ | async\"></component>\n     * ```\n     *\n     * The problem is `async` pipe just marks the component and all its ancestors as dirty.\n     * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked components.\n     *\n     * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\n     * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\n     *\n     * `ngrxPush` pipe solves that problem.\n     *\n     * Included Features:\n     *  - Take observables or promises, retrieve their values and render the value to the template\n     *  - Handling null and undefined values in a clean unified/structured way\n     *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\n     *  - Distinct same values in a row to increase performance\n     *  - Coalescing of change detection calls to boost performance\n     *\n     * @usageNotes\n     *\n     * ### Examples\n     *\n     * `ngrxPush` pipe solves that problem. It can be used like shown here:\n     * ```html\n     * {{observable$ | ngrxPush}}\n     * <ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>\n     * <component [value]=\"observable$ | ngrxPush\"></component>\n     * ```\n     *\n     * @publicApi\n     */\n    var PushPipe = /** @class */ (function () {\n        function PushPipe(cdRef, ngZone) {\n            var _this = this;\n            this.configSubject = new rxjs.Subject();\n            this.config$ = this.configSubject\n                .asObservable()\n                .pipe(operators.distinctUntilChanged());\n            this.updateViewContextObserver = {\n                // assign value that will get returned from the transform function on the next change detection\n                next: function (value) { return (_this.renderedValue = value); },\n            };\n            this.resetContextObserver = {\n                next: function (value) { return (_this.renderedValue = undefined); },\n            };\n            this.configurableBehaviour = function (o$) {\n                return o$.pipe(operators.withLatestFrom(_this.config$), operators.map(function (_a) {\n                    var _b = tslib.__read(_a, 2), value$ = _b[0], config = _b[1];\n                    // As discussed with Brandon we keep it here\n                    // because in the beta we implement configuration behavior here\n                    return value$.pipe();\n                }));\n            };\n            this.cdAware = createCdAware({\n                work: setUpWork({\n                    ngZone: ngZone,\n                    cdRef: cdRef,\n                    context: cdRef.context,\n                }),\n                updateViewContextObserver: this.updateViewContextObserver,\n                resetContextObserver: this.resetContextObserver,\n                configurableBehaviour: this.configurableBehaviour,\n            });\n            this.subscription = this.cdAware.subscribe();\n        }\n        PushPipe.prototype.transform = function (potentialObservable, config) {\n            if (config === void 0) { config = { optimized: true }; }\n            this.configSubject.next(config);\n            this.cdAware.next(potentialObservable);\n            return this.renderedValue;\n        };\n        PushPipe.prototype.ngOnDestroy = function () {\n            this.subscription.unsubscribe();\n        };\n        PushPipe = tslib.__decorate([\n            core.Pipe({ name: 'ngrxPush', pure: false }),\n            tslib.__metadata(\"design:paramtypes\", [core.ChangeDetectorRef, core.NgZone])\n        ], PushPipe);\n        return PushPipe;\n    }());\n\n    /**\n     * @Directive LetDirective\n     *\n     * @description\n     *\n     * The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\n     * It also helps with several internal processing under the hood.\n     *\n     * The current way of binding an observable to the view looks like that:\n     * ```html\n     * <ng-container *ngIf=\"observableNumber$ as n\">\n     * <app-number [number]=\"n\">\n     * </app-number>\n     * <app-number-special [number]=\"n\">\n     * </app-number-special>\n     * </ng-container>\n     *  ```\n     *\n     *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\n     *\n     * Included Features:\n     * - binding is always present. (`*ngIf=\"truthy$\"`)\n     * - it takes away the multiple usages of the `async` or `ngrxPush` pipe\n     * - a unified/structured way of handling null and undefined\n     * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)\n     * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ɵdetectChanges`)\n     * - distinct same values in a row (distinctUntilChanged operator),\n     *\n     * @usageNotes\n     *\n     * ### Examples\n     *\n     * The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template\n     * `<ng-container *ngrxLet=\"observableNumber$ as c\"></ng-container>`\n     *\n     * ```html\n     * <ng-container *ngrxLet=\"observableNumber$ as n\">\n     * <app-number [number]=\"n\">\n     * </app-number>\n     * </ng-container>\n     *\n     * <ng-container *ngrxLet=\"observableNumber$; let n\">\n     * <app-number [number]=\"n\">\n     * </app-number>\n     * </ng-container>\n     * ```\n     *\n     * In addition to that it provides us information from the whole observable context.\n     * We can track the observables:\n     * - next value\n     * - error value\n     * - complete state\n     *\n     * ```html\n     * <ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\n     * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\n     * </app-number>\n     * <ng-container *ngIf=\"e\">\n     * There is an error: {{e}}\n     * </ng-container>\n     * <ng-container *ngIf=\"c\">\n     * Observable completed: {{c}}\n     * </ng-container>\n     * </ng-container>\n     * ```\n     *\n     * @publicApi\n     */\n    var LetDirective = /** @class */ (function () {\n        function LetDirective(cdRef, ngZone, templateRef, viewContainerRef) {\n            var _this = this;\n            this.templateRef = templateRef;\n            this.viewContainerRef = viewContainerRef;\n            this.ViewContext = {\n                $implicit: undefined,\n                ngrxLet: undefined,\n                $error: false,\n                $complete: false,\n            };\n            this.configSubject = new rxjs.ReplaySubject();\n            this.config$ = this.configSubject.pipe(operators.filter(function (v) { return v !== undefined && v !== null; }), operators.distinctUntilChanged(), operators.startWith({ optimized: true }));\n            this.resetContextObserver = {\n                next: function () {\n                    // if not initialized no need to set undefined\n                    if (_this.embeddedView) {\n                        _this.ViewContext.$implicit = undefined;\n                        _this.ViewContext.ngrxLet = undefined;\n                        _this.ViewContext.$error = false;\n                        _this.ViewContext.$complete = false;\n                    }\n                },\n            };\n            this.updateViewContextObserver = {\n                next: function (value) {\n                    // to have init lazy\n                    if (!_this.embeddedView) {\n                        _this.createEmbeddedView();\n                    }\n                    _this.ViewContext.$implicit = value;\n                    _this.ViewContext.ngrxLet = value;\n                },\n                error: function (error) {\n                    // to have init lazy\n                    if (!_this.embeddedView) {\n                        _this.createEmbeddedView();\n                    }\n                    _this.ViewContext.$error = true;\n                },\n                complete: function () {\n                    // to have init lazy\n                    if (!_this.embeddedView) {\n                        _this.createEmbeddedView();\n                    }\n                    _this.ViewContext.$complete = true;\n                },\n            };\n            this.configurableBehaviour = function (o$) {\n                return o$.pipe(operators.withLatestFrom(_this.config$), \n                // @NOTICE: unused config => As discussed with Brandon we keep it here because in the beta release we implement configuration behavior here\n                operators.map(function (_a) {\n                    var _b = tslib.__read(_a, 2), value$ = _b[0], config = _b[1];\n                    return value$.pipe(operators.catchError(function (e) { return rxjs.EMPTY; }));\n                }));\n            };\n            this.cdAware = createCdAware({\n                work: setUpWork({\n                    cdRef: cdRef,\n                    ngZone: ngZone,\n                    context: cdRef.context,\n                }),\n                resetContextObserver: this.resetContextObserver,\n                updateViewContextObserver: this.updateViewContextObserver,\n                configurableBehaviour: this.configurableBehaviour,\n            });\n            this.subscription = this.cdAware.subscribe();\n        }\n        LetDirective.ngTemplateContextGuard = function (dir, ctx) {\n            return true;\n        };\n        Object.defineProperty(LetDirective.prototype, \"ngrxLet\", {\n            set: function (potentialObservable) {\n                this.cdAware.next(potentialObservable);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LetDirective.prototype, \"ngrxLetConfig\", {\n            set: function (config) {\n                this.configSubject.next(config || { optimized: true });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LetDirective.prototype.createEmbeddedView = function () {\n            this.embeddedView = this.viewContainerRef.createEmbeddedView(this.templateRef, this.ViewContext);\n        };\n        LetDirective.prototype.ngOnDestroy = function () {\n            this.subscription.unsubscribe();\n            this.viewContainerRef.clear();\n        };\n        tslib.__decorate([\n            core.Input(),\n            tslib.__metadata(\"design:type\", Object),\n            tslib.__metadata(\"design:paramtypes\", [Object])\n        ], LetDirective.prototype, \"ngrxLet\", null);\n        tslib.__decorate([\n            core.Input(),\n            tslib.__metadata(\"design:type\", Object),\n            tslib.__metadata(\"design:paramtypes\", [Object])\n        ], LetDirective.prototype, \"ngrxLetConfig\", null);\n        LetDirective = tslib.__decorate([\n            core.Directive({ selector: '[ngrxLet]' }),\n            tslib.__metadata(\"design:paramtypes\", [core.ChangeDetectorRef,\n                core.NgZone,\n                core.TemplateRef,\n                core.ViewContainerRef])\n        ], LetDirective);\n        return LetDirective;\n    }());\n\n    var DECLARATIONS = [LetDirective, PushPipe];\n    var EXPORTS = [DECLARATIONS];\n    var ReactiveComponentModule = /** @class */ (function () {\n        function ReactiveComponentModule() {\n        }\n        ReactiveComponentModule = tslib.__decorate([\n            core.NgModule({\n                declarations: [DECLARATIONS],\n                exports: [EXPORTS],\n            })\n        ], ReactiveComponentModule);\n        return ReactiveComponentModule;\n    }());\n\n    /**\n     * DO NOT EDIT\n     *\n     * This file is automatically generated at build\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.LetDirective = LetDirective;\n    exports.PushPipe = PushPipe;\n    exports.ReactiveComponentModule = ReactiveComponentModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=component.umd.js.map\n"]}