{"version":3,"sources":["modules/component/component.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ngrx","component","tslib","ng","core","rxjs","operators","this","hasZone","z","constructor","name","setUpWork","cfg","render","getChangeDetectionHandler","ngZone","cdRef","isIvy","getGlobalThis","globalThis","window","undefined","probe","ɵmarkDirty","ɵdetectChanges","markForCheck","bind","detectChanges","context","createCdAware","observablesSubject","Subject","observables$","pipe","distinctUntilChanged","map","v","toObservableValue","p","of","isObservableGuard","potentialObservable","isObservable","isPromiseGuard","value","subscribe","then","from","Error","tap","resetContextObserver","next","work","value$","updateViewContextObserver","configurableBehaviour","switchAll","PushPipe","_this","configSubject","config$","asObservable","renderedValue","o$","withLatestFrom","_a","__read","cdAware","subscription","prototype","transform","config","optimized","ngOnDestroy","unsubscribe","__decorate","Pipe","pure","__metadata","ChangeDetectorRef","NgZone","LetDirective","templateRef","viewContainerRef","ViewContext","$implicit","ngrxLet","$error","$complete","ReplaySubject","filter","startWith","embeddedView","createEmbeddedView","error","complete","catchError","e","EMPTY","ngTemplateContextGuard","dir","ctx","Object","defineProperty","set","enumerable","configurable","clear","Input","Directive","selector","TemplateRef","ViewContainerRef","DECLARATIONS","ReactiveComponentModule","NgModule","declarations"],"mappings":"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","sourcesContent":["/**\n * @license NgRx 9.0.0+10.sha-464073d\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/core'), require('rxjs'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@ngrx/component', ['exports', 'tslib', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ngrx = global.ngrx || {}, global.ngrx.component = {}), global.tslib, global.ng.core, global.rxjs, global.rxjs.operators));\n}(this, (function (exports, tslib, core, rxjs, operators) { 'use strict';\n\n    // Returns a reference to global thin\n    // - Browser\n    // - SSR\n    // - Tests\n    function getGlobalThis() {\n        return (globalThis || self || window);\n    }\n\n    // Table for ng global presence in ViewEngine and Ivy for prod/dev modes:\n    //\n    // | render     |  ViewEngine    |  ViewEngine    |      Ivy          |      Ivy          |\n    // | mode       |     prod       |      dev       |      prod         |      dev          |\n    // | ng         |     present    |     present    |     undefined     |     present       |\n    // | ng.probe   |     present    |     present    |     undefined     |     undefined     |\n    //\n    // So for Ivy we need to make sure that ng is undefined or,\n    // in case of dev environment, ng.probe is undefined\n    function isIvy() {\n        var ng = getGlobalThis().ng;\n        // Is the global ng object is unavailable?\n        // ng === undefined in Ivy production mode\n        // View Engine has the ng object both in development mode and production mode.\n        return (ng === undefined ||\n            // in case we are in dev mode in ivy\n            // `probe` property is available on ng object we use View Engine.\n            ng.probe === undefined);\n    }\n\n    function hasZone(z) {\n        return z.constructor.name !== 'NoopNgZone';\n    }\n\n    function getChangeDetectionHandler(ngZone, cdRef) {\n        if (isIvy()) {\n            return hasZone(ngZone) ? core.ɵmarkDirty : core.ɵdetectChanges;\n        }\n        else {\n            return hasZone(ngZone)\n                ? cdRef.markForCheck.bind(cdRef)\n                : cdRef.detectChanges.bind(cdRef);\n        }\n    }\n    function getDetectChanges(ngZone, cdRef) {\n        if (isIvy()) {\n            return !hasZone(ngZone) ? core.ɵdetectChanges : core.ɵmarkDirty;\n        }\n        else {\n            return hasZone(ngZone)\n                ? cdRef.markForCheck.bind(cdRef)\n                : cdRef.detectChanges.bind(cdRef);\n        }\n    }\n\n    function isPromiseGuard(value) {\n        return (!!value &&\n            typeof value.subscribe !== 'function' &&\n            typeof value.then === 'function');\n    }\n    function isObservableGuard(potentialObservable) {\n        return rxjs.isObservable(potentialObservable);\n    }\n    function isOperateFnArrayGuard(op) {\n        return op.every(function (i) { return typeof i !== 'string'; });\n    }\n    function isStringArrayGuard(op) {\n        return op.every(function (i) { return typeof i !== 'string'; });\n    }\n    function isDefinedGuard(opr) {\n        return !!opr;\n    }\n    function isIterableGuard(obj) {\n        if (obj === undefined) {\n            return false;\n        }\n        return typeof obj[Symbol.iterator] === 'function';\n    }\n\n    function toObservableValue(p) {\n        // Comparing to the literal null value with the == operator covers both null and undefined values.\n        if (p === null) {\n            return rxjs.of(p);\n        }\n        if (p === undefined) {\n            return rxjs.of(p);\n        }\n        if (isObservableGuard(p)) {\n            return p;\n        }\n        if (isPromiseGuard(p)) {\n            return rxjs.from(p);\n        }\n        throw new Error('Argument not observable. Only null/undefined or Promise/Observable-like values are allowed.');\n    }\n\n    function setUpWork(cfg) {\n        var render = getChangeDetectionHandler(cfg.ngZone, cfg.cdRef);\n        return function () { return render(cfg.context); };\n    }\n    /**\n     * class CdAware\n     *\n     * @description\n     * This abstract class holds all the shared logic for the push pipe and the let directive\n     * responsible for change detection\n     * If you extend this class you need to implement how the update of the rendered value happens.\n     * Also custom behaviour is something you need to implement in the extending class\n     */\n    function createCdAware(cfg) {\n        var observablesSubject = new rxjs.Subject();\n        // We have to defer the setup of observables$ until subscription as getConfigurableBehaviour is defined in the\n        // extending class. So getConfigurableBehaviour is not available in the abstract layer\n        var observables$ = observablesSubject.pipe(\n        // Ignore potential observables of the same instances\n        operators.distinctUntilChanged(), \n        // Try to convert it to values, throw if not possible\n        operators.map(function (v) { return toObservableValue(v); }), operators.tap(function (v) {\n            cfg.resetContextObserver.next(v);\n            cfg.work();\n        }), operators.map(function (value$) {\n            return value$.pipe(operators.distinctUntilChanged(), operators.tap(cfg.updateViewContextObserver));\n        }), \n        // e.g. coalescing\n        cfg.configurableBehaviour, \n        // Unsubscribe from previous observables\n        // Then flatten the latest internal observables into the output\n        // @NOTICE applied behaviour (on the values, not the observable) will fire here\n        operators.switchAll(), operators.tap(function () { return cfg.work(); }));\n        return {\n            next: function (value) {\n                observablesSubject.next(value);\n            },\n            subscribe: function () {\n                return observables$.subscribe();\n            },\n        };\n    }\n\n    /**\n     * @Pipe PushPipe\n     * @description\n     *\n     * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n     * It contains intelligent handling of change detection to enable us\n     * running in zone-full as well as zone-less mode without any changes to the code.\n     *\n     * The current way of binding an observable to the view looks like that:\n     *  ```html\n     *  {{observable$ | async}}\n     * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\n     * <component [value]=\"observable$ | async\"></component>\n     * ```\n     *\n     * The problem is `async` pipe just marks the component and all its ancestors as dirty.\n     * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked components.\n     *\n     * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\n     * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\n     *\n     * `ngrxPush` pipe solves that problem.\n     *\n     * Included Features:\n     *  - Take observables or promises, retrieve their values and render the value to the template\n     *  - Handling null and undefined values in a clean unified/structured way\n     *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\n     *  - Distinct same values in a row to increase performance\n     *  - Coalescing of change detection calls to boost performance\n     *\n     * @usageNotes\n     *\n     * ### Examples\n     *\n     * `ngrxPush` pipe solves that problem. It can be used like shown here:\n     * ```html\n     * {{observable$ | ngrxPush}}\n     * <ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>\n     * <component [value]=\"observable$ | ngrxPush\"></component>\n     * ```\n     *\n     * @publicApi\n     */\n    var PushPipe = /** @class */ (function () {\n        function PushPipe(cdRef, ngZone) {\n            var _this = this;\n            this.configSubject = new rxjs.Subject();\n            this.config$ = this.configSubject\n                .asObservable()\n                .pipe(operators.distinctUntilChanged());\n            this.updateViewContextObserver = {\n                // assign value that will get returned from the transform function on the next change detection\n                next: function (value) { return (_this.renderedValue = value); },\n            };\n            this.resetContextObserver = {\n                next: function (value) { return (_this.renderedValue = undefined); },\n            };\n            this.configurableBehaviour = function (o$) {\n                return o$.pipe(operators.withLatestFrom(_this.config$), operators.map(function (_a) {\n                    var _b = tslib.__read(_a, 2), value$ = _b[0], config = _b[1];\n                    // As discussed with Brandon we keep it here\n                    // because in the beta we implement configuration behavior here\n                    return value$.pipe();\n                }));\n            };\n            this.cdAware = createCdAware({\n                work: setUpWork({\n                    ngZone: ngZone,\n                    cdRef: cdRef,\n                    context: cdRef.context,\n                }),\n                updateViewContextObserver: this.updateViewContextObserver,\n                resetContextObserver: this.resetContextObserver,\n                configurableBehaviour: this.configurableBehaviour,\n            });\n            this.subscription = this.cdAware.subscribe();\n        }\n        PushPipe.prototype.transform = function (potentialObservable, config) {\n            if (config === void 0) { config = { optimized: true }; }\n            this.configSubject.next(config);\n            this.cdAware.next(potentialObservable);\n            return this.renderedValue;\n        };\n        PushPipe.prototype.ngOnDestroy = function () {\n            this.subscription.unsubscribe();\n        };\n        PushPipe = tslib.__decorate([\n            core.Pipe({ name: 'ngrxPush', pure: false }),\n            tslib.__metadata(\"design:paramtypes\", [core.ChangeDetectorRef, core.NgZone])\n        ], PushPipe);\n        return PushPipe;\n    }());\n\n    /**\n     * @Directive LetDirective\n     *\n     * @description\n     *\n     * The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\n     * It also helps with several internal processing under the hood.\n     *\n     * The current way of binding an observable to the view looks like that:\n     * ```html\n     * <ng-container *ngIf=\"observableNumber$ as n\">\n     * <app-number [number]=\"n\">\n     * </app-number>\n     * <app-number-special [number]=\"n\">\n     * </app-number-special>\n     * </ng-container>\n     *  ```\n     *\n     *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\n     *\n     * Included Features:\n     * - binding is always present. (`*ngIf=\"truthy$\"`)\n     * - it takes away the multiple usages of the `async` or `ngrxPush` pipe\n     * - a unified/structured way of handling null and undefined\n     * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)\n     * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ɵdetectChanges`)\n     * - distinct same values in a row (distinctUntilChanged operator),\n     *\n     * @usageNotes\n     *\n     * ### Examples\n     *\n     * The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template\n     * `<ng-container *let=\"observableNumber$ as c\"></ng-container>`\n     *\n     * ```html\n     * <ng-container *ngrxLet=\"observableNumber$ as n\">\n     * <app-number [number]=\"n\">\n     * </app-number>\n     * </ng-container>\n     *\n     * <ng-container *ngrxLet=\"observableNumber$; let n\">\n     * <app-number [number]=\"n\">\n     * </app-number>\n     * </ng-container>\n     * ```\n     *\n     * In addition to that it provides us information from the whole observable context.\n     * We can track the observables:\n     * - next value\n     * - error value\n     * - complete state\n     *\n     * ```html\n     * <ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\n     * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\n     * </app-number>\n     * <ng-container *ngIf=\"e\">\n     * There is an error: {{e}}\n     * </ng-container>\n     * <ng-container *ngIf=\"c\">\n     * Observable completed: {{c}}\n     * </ng-container>\n     * </ng-container>\n     * ```\n     *\n     * @publicApi\n     */\n    var LetDirective = /** @class */ (function () {\n        function LetDirective(cdRef, ngZone, templateRef, viewContainerRef) {\n            var _this = this;\n            this.templateRef = templateRef;\n            this.viewContainerRef = viewContainerRef;\n            this.ViewContext = {\n                $implicit: undefined,\n                ngrxLet: undefined,\n                $error: false,\n                $complete: false,\n            };\n            this.configSubject = new rxjs.ReplaySubject();\n            this.config$ = this.configSubject.pipe(operators.filter(function (v) { return v !== undefined && v !== null; }), operators.distinctUntilChanged(), operators.startWith({ optimized: true }));\n            this.resetContextObserver = {\n                next: function () {\n                    // if not initialized no need to set undefined\n                    if (_this.embeddedView) {\n                        _this.ViewContext.$implicit = undefined;\n                        _this.ViewContext.ngrxLet = undefined;\n                        _this.ViewContext.$error = false;\n                        _this.ViewContext.$complete = false;\n                    }\n                },\n            };\n            this.updateViewContextObserver = {\n                next: function (value) {\n                    // to have init lazy\n                    if (!_this.embeddedView) {\n                        _this.createEmbeddedView();\n                    }\n                    _this.ViewContext.$implicit = value;\n                    _this.ViewContext.ngrxLet = value;\n                },\n                error: function (error) {\n                    // to have init lazy\n                    if (!_this.embeddedView) {\n                        _this.createEmbeddedView();\n                    }\n                    _this.ViewContext.$error = true;\n                },\n                complete: function () {\n                    // to have init lazy\n                    if (!_this.embeddedView) {\n                        _this.createEmbeddedView();\n                    }\n                    _this.ViewContext.$complete = true;\n                },\n            };\n            this.configurableBehaviour = function (o$) {\n                return o$.pipe(operators.withLatestFrom(_this.config$), \n                // @NOTICE: unused config => As discussed with Brandon we keep it here because in the beta release we implement configuration behavior here\n                operators.map(function (_a) {\n                    var _b = tslib.__read(_a, 2), value$ = _b[0], config = _b[1];\n                    return value$.pipe(operators.catchError(function (e) { return rxjs.EMPTY; }));\n                }));\n            };\n            this.cdAware = createCdAware({\n                work: setUpWork({\n                    cdRef: cdRef,\n                    ngZone: ngZone,\n                    context: cdRef.context,\n                }),\n                resetContextObserver: this.resetContextObserver,\n                updateViewContextObserver: this.updateViewContextObserver,\n                configurableBehaviour: this.configurableBehaviour,\n            });\n            this.subscription = this.cdAware.subscribe();\n        }\n        LetDirective.ngTemplateContextGuard = function (dir, ctx) {\n            return true;\n        };\n        Object.defineProperty(LetDirective.prototype, \"ngrxLet\", {\n            set: function (potentialObservable) {\n                this.cdAware.next(potentialObservable);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LetDirective.prototype, \"ngrxLetConfig\", {\n            set: function (config) {\n                this.configSubject.next(config || { optimized: true });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LetDirective.prototype.createEmbeddedView = function () {\n            this.embeddedView = this.viewContainerRef.createEmbeddedView(this.templateRef, this.ViewContext);\n        };\n        LetDirective.prototype.ngOnDestroy = function () {\n            this.subscription.unsubscribe();\n            this.viewContainerRef.clear();\n        };\n        tslib.__decorate([\n            core.Input(),\n            tslib.__metadata(\"design:type\", Object),\n            tslib.__metadata(\"design:paramtypes\", [Object])\n        ], LetDirective.prototype, \"ngrxLet\", null);\n        tslib.__decorate([\n            core.Input(),\n            tslib.__metadata(\"design:type\", Object),\n            tslib.__metadata(\"design:paramtypes\", [Object])\n        ], LetDirective.prototype, \"ngrxLetConfig\", null);\n        LetDirective = tslib.__decorate([\n            core.Directive({ selector: '[ngrxLet]' }),\n            tslib.__metadata(\"design:paramtypes\", [core.ChangeDetectorRef,\n                core.NgZone,\n                core.TemplateRef,\n                core.ViewContainerRef])\n        ], LetDirective);\n        return LetDirective;\n    }());\n\n    var DECLARATIONS = [LetDirective, PushPipe];\n    var EXPORTS = [DECLARATIONS];\n    var ReactiveComponentModule = /** @class */ (function () {\n        function ReactiveComponentModule() {\n        }\n        ReactiveComponentModule = tslib.__decorate([\n            core.NgModule({\n                declarations: [DECLARATIONS],\n                exports: [EXPORTS],\n            })\n        ], ReactiveComponentModule);\n        return ReactiveComponentModule;\n    }());\n\n    /**\n     * DO NOT EDIT\n     *\n     * This file is automatically generated at build\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.LetDirective = LetDirective;\n    exports.PushPipe = PushPipe;\n    exports.ReactiveComponentModule = ReactiveComponentModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=component.umd.js.map\n"]}